<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="multimodule-web-spring">
  <title>Multi-module Enterprise Project</title>

  <section id="multimodule-web-spring-sect-intro">
    <title>Einleitung</title>

    <para>In diesem Kapitel werden wir, aufbauend auf die Beispiele der
    Kapitel 6: Ein Multi-Projekt-Modul sowie Kapitel 5. Eine einfache
    Web-Anwendung, ein Multi-Modul-Projekt entwickeln. In dieses Beispiel
    werden wir das Spring Framework und auch Hibernate einbinden, um eine
    einfache Web-Anwendung und gleichzeitig ein einfaches
    Befehlszeilen-Dienstprogramm zum Lesen von Daten des Yahoo! Wetter
    Dienstes zu erstellen. Den Quellcode des "Simple Weather" Beispiels aus
    <xref linkend="customizing" /> (Kapitel 4: Anpassen eines Maven Projekts)
    werden wir mit dem Quellcode aus <xref linkend="web" /> (Kapitel 5: Eine
    einfache Web-Anwendung) kombinieren. Im Laufe der Entwicklung dieses Multi
    Modul Projekts werden wir Fragenstellungen bezüglich des Einsatzes von
    Maven erörtern und verschiedene Möglichkeiten der Umsetzung darlegen, um
    den Aufbau modularer Projekte zu fördern und die Wiederverwendung von
    Komponenten aufzuzeigen.</para>

    <section id="multimodule-web-spring-sect-downloading-example">
      <title>Herunterladen der Beispiele dieses Kapitels</title>

      <para>Das multi-modulare Projekt welches wir in diesem Kapitel erstellen
      werden, besteht aus modifizierten Versionen der Projekte der
      vorhergehenden Kapitel; <xref linkend="customizing" /> (Kapitel 4:
      Anpassen eines Maven Projekts) sowie <xref linkend="web" /> (Kapitel 5:
      Eine einfache Web-Anwendung). Wir werden dieses multi-modulare Projekt
      nicht mit dem Archetype Maven Plugin generieren. Wir empfehlen Ihnen
      eine Kopie der Beispiel-Code als zusätzliche Referenz beim Lesen der
      Inhalte in diesem Kapitel herunterzuladen. Das Beispielprojekt dieses
      Kapitel zusammen mit den anderen Beispielen dieses Buchs kann von <ulink
      type=""
      url="http://www.sonatype.com/book/mvn-examples-1.0.zip">http://www.sonatype.com/book/mvn-examples-1.0.zip</ulink>
      oder <ulink type=""
      url="http://www.sonatype.com/book/mvn-examples-1.0.tar.gz">http://books.sonatype.com/maven-book/mvn-examples-1.0.tar.gz</ulink>
      heruntergeladen werden. Entpacken Sie das Archiv in ein beliebiges
      Verzeichnis, und gehen Sie dann zum Verzeichnis
      <code><filename>/ch07</filename></code>. Darin finden Sie ein
      Verzeichnis mit dem Namen
      <code><filename>/simple-parent</filename></code> welches das multi
      modulare Projekt dieses Kapitels enthält. Innerhalb des Verzeichnisses
      <code><filename>/simple-parent</filename> </code>werden Sie auf eine
      <filename>pom.xml</filename>-Datei sowie zwei Unterverzeichnisse
      <code><filename>/simple weather</filename></code> und
      <code><filename>/simple web app</filename></code> stossen welche den
      Quellcode für dieses Kapitel enthalten.</para>
    </section>

    <section id="multimodule-web-spring-sect-project-description">
      <title>Multi-Modul Enterprise Projekt </title>

      <para>Die Komplexität einer extensiven Enterprise Applikation
      aufzuzeigen würde den Rahmen dieses Buches bei weitem sprengen. Solche
      Projekte sind gekennzeichnet durch den Einsatz mehrerer Datenbanken, der
      Integration externer Systeme und Teilprojekte welche weiter z.B. nach
      Abteilungen aufgeteilt werden. Solcherlei Projekte beinhalten in der
      Regel tausende von Zeilen Quellcode, und reflektieren die Arbeit von
      Dutzenden oder Hunderten von Software-Entwicklern. Da ein solches
      Beispiel den Rahmen des Buches sprengen würde, können wir Ihnen hier
      lediglich anhand eines Beispielprojekts die Komplexitäten größerer
      Enterprise-Anwendungen aufzeigen. Im Abschluss geben wir einige
      Ratschläge der modularen Strukturierung welche über dieses Kapitel
      hinausgehen. </para>

      <para>In diesem Kapitel wenden wir uns einem Multi Modul Projekt zu,
      welches zwei Benutzerschnittstellen definiert: ein
      Befehlszeilen-Abfrage-Tool für die Yahoo! Wetter-Dienste, sowie eine
      Web-Anwendung welche auf diese Dienste aufbaut. Beide Anwendungen
      speichern die Resultate der Abfragen in einer eingebetteten Datenbank.
      Beide Anwendungen erlauben es dem Benutzer auf historisierte
      Abfragewerte der eingebetteten Datenbank zuzugreifen. Beide Anwendungen
      teilen sich die Anwendungslogik und auch eine Persistenz Bibliothek.
      Dieses Kapitel baut auf den Code zur Auswertung des Yahoo! Wetter
      Dienstes auf, welcher in <xref linkend="customizing" /> (Kapitel 4
      Anpassen eines Maven Projekts) eingeführt wurde. Dieses Projekt gliedert
      sich in fünf Untermodule wie in <xref
      linkend="fig-multimodule-web-spring-projects" /> (Abbildung 7.1:
      "Beziehungen der Module einer komplexen Enterprise Anwendung")
      veranschaulicht wird.</para>

      <figure id="fig-multimodule-web-spring-projects">
        <title>Beziehungen der Module einer komplexen Enterprise
        Anwendung</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/multimodule-web-spring_projects.png"
                       scalefit="1" width="8in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Aus <xref linkend="fig-multimodule-web-spring-projects" />
      (Abbildung 7.1: "Beziehungen der Module einer komplexen Enterprise
      Anwendung") sehen Sie, dass es fünf Untermodule des "Eltern"-Projekt
      gibt. Diese sind:</para>

      <variablelist>
        <varlistentry>
          <term>simple-model</term>

          <listitem>
            <para>Dieses Modul definiert ein einfaches Objektmodell, welches
            die vom Yahoo! Wetter-Dienst zurückgegebenen Daten abbildet.
            Dieses Objektmodell beinhaltet die Objekte
            <classname>Weather</classname>, <classname>Condition</classname>,
            <classname>Atmosphere</classname>,
            <classname>Location</classname><classname> und Wind
            (</classname>Wetterlage, Zustand, Atmosphäre, Ort sowie
            Windrichtung). Beim parsen der vom Yahoo! Wetter Dienst
            zurückgegebenen <acronym>XML</acronym>-Antwort werden
            <classname>weather</classname> Objekte erstellt, welche an die
            Anwendung weitergegeben werden. Dieses Projekt beinhaltet Objekte
            welche mit Hibernate 3 Annotations versehen sind um die Zuordnung
            eines jeden Objektes zu einem Datensatz in der Datenbank
            sicherzustellen.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-weather</term>

          <listitem>
            <para>Dieses Modul enthält alle Logik welche erforderlich ist, um
            Daten des Yahoo! Wetter-Dienstes anzuziehen und das zurückgegebene
            <acronym>XML</acronym> auszuwerten. Aus dem zurückgegebenen
            <acronym>XML</acronym> werden anschliessend Objekte wie diese in
            "<varname>Simple Model</varname>" definiert wurden, erstellt. Das
            "<varname>Simple Weather</varname>"-Modul ist abhängig vom Modul
            "<varname>Simple Model</varname>". "<varname>Simple
            Weather</varname>" stellt einen Dienst bereit
            ("<classname>WeatherService</classname>"), welcher sowohl von
            "<varname>Simple Command</varname>" wie auch von "<varname>Simple
            Web</varname>" konsumiert wird. </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-persist</term>

          <listitem>
            <para>Dieses Modul enthält einige Data Access Objekte
            (<acronym>DAO</acronym>). Konfiguriert, um
            <classname>Weather</classname> Objekte in einer eingebetteten
            Datenbank abzuspeichern. Beide Benutzerschnittstellen dieser
            multi-modularen Anwendung (Web/Befehlszeile) bauen auf einfache
            <acronym>DAO</acronym>s (Data Access Objekts=Datenzugriffsobjekte)
            auf, welche zur Speicherung (speichern=to persist) herangezogen
            werden. Die Modellobjekte welche in "<varname>Simple
            Model</varname>" bereitgestellt werden, können von den
            <acronym>DAO</acronym>s sowohl verstanden wie auch zurückgegeben
            werden. "<varname>Simple Persist</varname>" ist direkt von
            "<varname>Simple Model</varname>" abhängig und definiert weitere
            Abhängigkeiten zu den Modellobjekten, gekennzeichnet durch
            Hibernate Annotations.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-webapp</term>

          <listitem>
            <para>Das Web-Anwendungs Projekt definiert zwei Spring
            <acronym>MVC</acronym>-Controller-Implementierungen welche unter
            Verwendung des <classname>WeatherService</classname> definiert
            werden, sowie die <acronym>DAO</acronym>s aus "<varname>Simple
            Persist</varname>". "<varname>Simple Web</varname>" verfügt über
            eine direkte Abhängigkeit zu "<varname>Simple Weather</varname>"
            sowie eine transitive Abhängigkeit zu "<varname>Simple
            Model</varname>".</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-command</term>

          <listitem>
            <para>Dieses Modul enthält eine einfache Befehlszeilen-Anwendung
            welche dazu eingesetzt werden kann, die Yahoo! Wetter-Dienste
            abzufragen. Das Modul enthält eine statisch definierte Klasse
            <methodname>main()</methodname> welche mit
            <classname>WeatherService</classname> aus "<varname>Simple
            Weather</varname>" sowie der <acronym>DAO</acronym>s welche in
            "<varname>Simple Persist</varname>" definiert wurden arbeitet.
            "<varname>Simple Command</varname>" hat eine direkte Abhängigkeit
            zu "<varname>Simple Weather</varname>" sowie "<varname>Simple
            Persist</varname>"; es besteht eine transitive Abhängigkeit zu
            "<varname>Simple Model</varname>".</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Hiermit ist das Beispiel in diesem Kapitel vorgestellt; es ist
      einfach genug um es in einem Lehrbuch einzuführen, und doch komplex
      genug um eine Aufspaltung in fünf Untermodule zu rechtfertigen. Während
      unser künstliches Beispiel ein Modell-Projekt von fünf Klassen, eine
      Persistenz-Bibliothek mit zwei Service-Klassen und eine
      Parsing-Bibliothek mit fünf oder sechs Klassen hat, kann ein
      tatsächliches "Reale-Welt-System" leicht ein Modell-Projekt mit
      hunderten von Klassen, mehrere Persistenz- und Service-Bibliotheken
      welche über mehrere Bereiche reichen, umfassen. Während wir versucht
      haben sicherzustellen, dass der Quellcode des Beispiels einfach genug
      ist, um diesen in einer Sitzung zu verstehen, haben wir uns ebenso
      bemüht ein modulares Beispiel zu erstellen. Es wäre nachvollziehbar,
      würden Sie nach der Betrachtung des Quellcodes, sich von Maven abwenden
      und den Eindruck mitnehmen, Maven ermuntere dazu Komplexität
      einzuführen, da das Beispiel lediglich fünf Klassen umfasst. Jedoch
      sollten Sie immer bedenken, dass wir keine Mühen scheuten, das einfache
      Beispiel anzureichern, um die Möglichkeiten zur Bearbeitung komplexer
      Fragestellungen beispielhaft aufzuzeigen und darzustellen, insbesondere
      die von Maven gegebenen Multi-Modul-Funktionalitäten.</para>
    </section>

    <section id="multimodule-web-spring-sect-example-tech">
      <title>Technologie des Beispiels</title>

      <para>Die in diesem Kapitel eingesetzten Technologien umfassen solche,
      welche zwar populär sind, aber nicht in direktem Zusammenhang mit dem
      Einsatz von Maven stehen. Die angedeuteten Technologien sind: das
      <productname>Spring Framework</productname> und
      <productname>Hibernate</productname>. Das Spring Framework stellt einen
      'Inversion of Control (<acronym>IoC</acronym>) Container' bereit, sowie
      eine Reihe von Frameworks welche auf die Vereinfachung der Interaktion
      mit verschiedenen <acronym>J2EE</acronym>-Bibliotheken abzielen. Mit dem
      Spring Framework als Fundament der Anwendungsentwicklung erhalten Sie
      Zugriff auf eine Reihe von hilfreichen Abstraktionen, welche Ihnen einen
      Großteil der mühseligen Fummelei im Umgang mit z.B. Persistenz
      Frameworks wie Hibernate oder <productname>iBatis</productname> oder
      auch Enterprise-<acronym>API</acronym>s wie <acronym>JDBC</acronym>,
      <acronym>JNDI</acronym> und <acronym>JMS</acronym> nehmen. Das Spring
      Framework hat in den vergangenen Jahren stark an Popularität gewonnen,
      insbesondere als Alternative zu den schwergewichtigen Enterprise
      Standards aus dem Hause Sun Microsystems. Hibernate ist ein weit
      verbreitetes Object-Relational-Mapping- (<acronym>ORM</acronym>-)
      Framework, das eine Interaktion mit relationalen Datenbanken
      bereitstellt, als ob es sich um eine Sammlung von Java-Objekten handele.
      Dieses Beispiel konzentriert sich auf den Aufbau einer einfachen
      Web-Anwendung und eines Befehlszeilen-Programms, welche, aufbauend auf
      das Spring Framework und Hibernate, eine Reihe von wiederverwendbaren
      Komponenten bereitstellt, welche es erlauben die bestehenden
      Wetter-Daten in einer eingebettete Datenbank abzulegen
      (persistieren).</para>

      <para>Wir haben uns entschlossen diese Frameworks einzubinden, um Ihnen
      am Beispiel aufzuzeigen, wie man beim Einsatz von Maven diese
      Technologien einbinden kann. Obschon es in das Kapitel eingestreut kurze
      Einführungen zu diesen Technologien gibt, so ist es nicht das erklärte
      Ziel dieses Kapitels diese Technologien im Detail darzustellen.
      Bezüglich weiterführender Dokumentation dieser Frameworks verweisen wir:
      bezüglich Spring auf die Projekt Website <ulink
      url="http://www.springframework.org">http://www.springframework.org</ulink>,
      bezüglich Hibernate auf den Projekt Website <ulink
      url="http://www.hibernate.org">http://www.hibernate.org</ulink>. Dieses
      Kapitel setzt als eingebettete Datenbank auf <acronym>HSQLDB</acronym>,
      weitere Informationen zu dieser Datenbank finden Sie auf der Projekt
      Website <ulink url="http://hsqldb.org">http://hsqldb.org</ulink>.</para>
    </section>
  </section>

  <section id="multimodule-web-spring-sect-simple-parent">
    <title>Das "Simple Parent" Projekt - Top Level</title>

    <para>Das "<varname>Simple Parent</varname>" Hauptmodul hat ein
    <acronym>POM</acronym> welches auf fünf Untermodule verweist: <indexterm
        class="startofrange" id="enterprise2a">
        <primary>simple parent project (example)</primary>

        <secondary>multimodule enterprise</secondary>
      </indexterm>(simple-command), <indexterm class="startofrange"
        id="enterprise2b">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>

        <tertiary>simple parent project</tertiary>
      </indexterm>(simple-model), (simple-weather), (simple-persist) und
    <indexterm class="startofrange" id="enterprise2c">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>

        <tertiary>simple parent project</tertiary>
      </indexterm>(simple-webapp). Das Top-Level POM
    (<filename>pom.xml</filename>-Datei) ist im <xref
    linkend="ex-multimodule-web-spring-parent" /> (Beispiel 7.1, "Simple
    Parent POM Projekt") dargestellt. </para>

    <example id="ex-multimodule-web-spring-parent">
      <title>Simple Parent POM Projekt</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
  &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;name&gt;Chapter 7 Simple Parent Project&lt;/name&gt;
 
  &lt;modules&gt;
    &lt;module&gt;simple-command&lt;/module&gt;
    &lt;module&gt;simple-model&lt;/module&gt;
    &lt;module&gt;simple-weather&lt;/module&gt;
    &lt;module&gt;simple-persist&lt;/module&gt;
    &lt;module&gt;simple-webapp&lt;/module&gt;
  &lt;/modules&gt;

  &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;configuration&gt;
            &lt;source&gt;1.5&lt;/source&gt;
            &lt;target&gt;1.5&lt;/target&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
   &lt;/pluginManagement&gt; 
  &lt;/build&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</programlisting>
    </example>

    <note>
      <para>Sollten Sie bereits mit Maven <acronym>POM</acronym>s vertraut
      sein, so werden Sie jetzt bemerken, dass dieses top level
      <acronym>POM</acronym> kein Element dependencyManagement definiert. Das
      Element dependencyManagement erlaubt es Ihnen, Abhängigkeitsversionen in
      einem einzigen top-level <acronym>POM</acronym> zu definieren und wird
      in <xref linkend="optimizing" /> (Kapitel 8: Optimieren und
      Refaktorieren von POMs) eingeführt.</para>
    </note>

    <para>Bemerken Sie bitte die Ähnlichkeiten dieses Hauptmodul
    <acronym>POM</acronym>s zu jenem Hauptmodul POM des Projekts in <xref
    linkend="ex-multimodule-parent-pom" /> (Kapitel 6.1: "Simple Parent
    Projekt POM"). Der einzige, wirkliche Unterschied zwischen diesen beiden
    <acronym>POM</acronym>s ist die Liste der Untermodule. Wo das
    vorangegangene Beispiel nur zwei Untermodule aufführte, hat dieses
    Hauptmodul deren fünf. In den nächsten Abschnitten wird jedes dieser fünf
    Untermodule in einigen Details dargestellt. Da unsere Beispiel
    Java-Annotationen einsetzt, haben wir es so konfiguriert, dass der
    Compiler auf die Java 5 Virtual Machine (<acronym>JVM</acronym>)
    aufsetzt.</para>
  </section>

  <section id="multimodule-web-spring-sect-simple-model-project">
    <title>Das Simple Model" Modul - Das Objektmodell</title>

    <para>Das erste, was die meisten Enterprise Projekte benötigen, ist ein
    Objekt-Modell. Ein Objekt-Modell erfasst die Grundmenge aller
    Domain-Objekte eines Systems. Ein Banken-System könnten ein Objekt-Modell
    haben, welches aus einem <classname>Konto</classname>,
    <classname>Kunden</classname>- und
    <classname>Transaktions</classname>-Objekt besteht, ein System zum
    Erfassen und Verbreiten von Sportergebnisse besässe ein
    <classname>Mannschafts</classname>- und ein
    <classname>Spiel</classname>-Objekt. Was auch immer Ihr Projekt umfasst,
    die Chancen stehen gut, dass Sie die entsprechenden Konzepte Ihres Systems
    in einem Objekt-Modell erfasst haben. Eine gängige Praxis im Umgang mit
    Maven ist es, dieses Modul separate auszulagern um es fortan als häufig
    referenziertes Modul weiterzuführen. In unserem System erfassen wir jede
    Abfrage des Yahoo! Wetter-Dienstes mit einem Objekt, das Objekt
    <classname>weather</classname>, welches weitere vier Objekte referenziert:
    Windrichtung, Chill und Geschwindigkeit werden in einem Objekt
    <classname>Wind</classname> erfasst. Standortdaten einschließlich der
    Postleitzahl, Stadt, Region und Land sind in einer Klasse
    <classname>Location</classname> zusammengefasst. Die atmosphärischen
    Bedingungen wie die Feuchtigkeit, maximale Sichtbarkeit, Luftdruck, und ob
    der Druck steigt oder fällt, wird in einer Klasse
    <classname>Atmosphere</classname> gehalten. Eine textuelle Beschreibung
    der Zustände, der Temperatur, und die Daten der Beobachtung werden einer
    Klasse <classname>Condition</classname> zusammengefasst.</para>

    <figure>
      <title>Einfaches Objektmodell für Wetter-Daten</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figs/web/multimodule-web-spring_object-model.png"
                     scalefit="1" width="5in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Die <filename>pom.xml</filename>-Datei für dieses schlichte Modell
    hat nur eine Abhängigkeitsdefinition welche der Erläuterung bedarf: Unser
    Objekt-Modell wird mit <indexterm>
        <primary>Hibernate annotations</primary>
      </indexterm><indexterm>
        <primary>annotations (Hibernate)</primary>
      </indexterm> Hibernate Annotations realisiert. Wir verwenden Annotations
    um die Modell-Objekte auf Tabellen einer relationalen Datenbank
    abzubilden. Die Abhängigkeit besteht zu <classname>org.hibernate:
    hibernate-annotaions: 3.3.0.ga</classname>. Werfen Sie einen Blick in
    diese <filename>pom.xml</filename> sowie einige der kommenden Beispiele
    worin dies verdeutlicht wird:</para>

    <example id="example_simple-model_pom.xml">
      <title>pom.xml des Projektmoduls: simple-model</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Object Model&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>

      <para>Unter
      <filename>/src/main/java/de/sonatype/Maven/weather/model</filename>
      liegt <filename>Weather.java</filename> welche das annotierte
      Wetter-Objekt-Modell beinhaltet. Das
      <classname>Weather</classname>-Objekt ist ein einfaches Java Bean. Das
      bedeutet, es werden private Member Variablen gesetzt
      (<varname>id</varname>, <varname>location</varname>,
      <varname>condition</varname>, <varname>wind</varname>,
      <varname>amosphere</varname> und <varname>date</varname>) welche durch
      public Getter und Setter-Methoden offengelegt werden. Dabei wird
      folgende Regel umgesetzt: gibt es ein String-Property mit dem Namen
      "name" so wird eine public Getter-Methode ohne Argumente namens
      <methodname>getName()</methodname> gesetzt, sowie eine public Setter
      Methode mit einem Argument <methodname>setName(String
      name)</methodname>; analog für andere Typen. Während wir hier die Getter
      und Setter-Methode für das <varname>id</varname>-Property zeigen, haben
      wir die Mehrheit der anderen Properties ausgelassen um an dieser Stelle
      einer Anzahl Bäume das Leben zu wahren.</para>
    </example>

    <example id="example_weather_model_object">
      <title>Annotiertes Wetter Modell Objekt</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.model;

import javax.persistence.*;

import java.util.Date;

@Entity
@NamedQueries({
  @NamedQuery(name="Weather.byLocation", 
              query="from Weather w where w.location = :location")
})
public class Weather {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne(cascade=CascadeType.ALL)
    private Location location;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Condition condition;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Wind wind;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Atmosphere atmosphere;

    private Date date;
    
    public Weather() {}

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    // Alle weiteren getter/setter Methoden ausgelassen...
}
</programlisting>
    </example>

    <para>In der Klasse <classname>Weather</classname>, setzen wir auf
    Hibernate Annotationen, um dem "<varname>simple persist</varname>" Projekt
    Anleitung zu geben. Diese Annotationen werden von Hibernate benutzt, um
    ein Objekt auf eine Tabelle einer relationalen Datenbank abzubilden.
    Während eine ausführliche Einführung in die Hibernate Annotationen weit
    über den Rahmen dieses Kapitels hinausgeht, hier eine kurze Erklärung für
    Neugierige: Die Annotation <classname>@Entity</classname> bezeichnet diese
    Klasse als zu persistierende Einheit, die <classname>@Table</classname>
    Annotation haben wir ausgelassen, Hibernate wird daher den Klassennamen
    als Tabellennamen einsetzen und so das Objekt
    <classname>Weather</classname> auf eine Tabelle
    <classname>Weather</classname> abbilden. Die
    <classname>@NamedQueries</classname> Annotation definiert eine Abfrage,
    welche vom <classname>WeatherDAO</classname> aus dem "<varname>Simple
    Persist</varname>" Projekt verwendet wird. Die Abfragesprache, welche von
    der <classname>@NamedQuery</classname> Annotation benutzt wird ist
    Hibernate Query Language (<acronym>HQL</acronym>). Jede Variable wird mit
    Annotationen versehen welche den Typ, die Spalte sowie jegliche
    Beziehungen der Spalte zu anderen Spalten definiert:</para>

    <variablelist>
      <varlistentry>
        <term role="plain"><varname>Id</varname></term>

        <listitem>
          <para>Das Property <varname>id</varname> wird mit
          <classname>@Id</classname> gekennzeichnet. Dies zeichnet das
          Property <varname>id</varname> als das Property aus, welches den
          Primärschlüssel bezüglich der Tabelle in der Datenbank trägt. Die
          Kennzeichnung <classname>@GeneratedValue</classname> bestimmt wie
          neue Primärschlüssel generiert werden. Im Falle von
          <varname>id</varname>, bestimmen wir den
          <classname>GenerationType</classname> <varname>IDENTITY</varname>,
          welcher auf die Verwendung des Datenbank eigenen
          Generierungsalgoryhtmus aufsetzt. </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term role="plain"><varname>Location</varname></term>

        <listitem>
          <para>Jede Instanz eines Wetter-Objekts
          (<classname>Weather</classname>) ist an eine Instanz eines Standort
          Objekts (<classname>Location</classname>) gebunden. Ein Standort
          Objekt repräsentiert eine Postleitzahl und die Kennzeichnung
          <classname>@ManyToOne</classname> stellt sicher, dass
          Wetter-Objekte, welche an den selben Standort gebunden sind auch auf
          dieselbe Instanz zeigen. Das Attribut <varname>cascade</varname> der
          Annotation <classname>@ManyToOne</classname> stellt sicher, dass wir
          bei jedem persistieren des Wetter Objekts auch das zugehörige
          Standort Objekt persistieren.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term role="plain"><varname>Condition</varname>,
        <varname>Wind</varname>, <varname>Atmosphere</varname></term>

        <listitem>
          <para>Jedes dieser Objekte wird mit einer Kennzeichnung von
          <classname>@OneToOne</classname> und dem
          <classname>CascadeType</classname> <varname>ALL</varname>
          abgebildet. Dies bedeutet, dass jedes Mal, wenn wir ein
          Wetter-Objekt speichern, eine Zeile in der Tabelle
          <classname>Weather</classname>, aber auch in den Tabellen
          <classname>Condition</classname>, <classname>Wind</classname> und
          <classname>Atmosphere</classname> erzeugt wird.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term role="plain"><varname>Date</varname></term>

        <listitem>
          <para>Das Property <varname>date</varname> ist nicht annotiert, das
          bedeutet, dass Hibernate in Bezug auf die Spalten alle Standardwerte
          benutzt um diese Zuordung zu definieren. Der Spaltenname wird als
          <varname>date</varname> gesetzt, und der Datentyp der Spalte auf den
          entsprechenden Typ um dem <classname>date-</classname>Objekt zu
          entsprechen. </para>

          <note>
            <para>Sollten Sie ein Property in der Abbildung nicht
            berücksichtingen, so würden Sie dieses Property mit
            <classname>@Transient</classname> annotieren.</para>
          </note>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Next, take a look at one of the secondary model objects,
    <classname>Condition</classname>, shown in <xref
    linkend="example_condition_model_object" />. This class also resides in
    <filename>src/main/java/org/sonatype/mavenbook/weather/model</filename>.</para>

    <para>Als nächstes, schauen Sie sich das weiterführende Objekt Modell
    <classname>Condition</classname> an. Diese Klasse ist ebenfalls unter
    <filename>/src/main/java/de/sonatype/maven/weather/model</filename>
    abgelegt. </para>

    <example id="example_condition_model_object">
      <title>'Condition' Modell Objekt des Projektes "simple-model"</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.model;

import javax.persistence.*;

@Entity
public class Condition {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Integer id;

    private String text;
    private String code;
    private String temp;
    private String date;

    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name="weather_id", nullable=false)
    private Weather weather;

    public Condition() {}

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    // Alle weiteren getter/setter Methoden ausgelassen...
}</programlisting>
    </example>

    <para>Die Klasse <classname>Condition</classname> entspricht der Klasse
    <classname>weather</classname>. Sie wird mit
    <classname>@Entity</classname> annotiert, und hat eine gleichartige
    Kennzeichnung des Properties <varname>id</varname>. Die Properties
    <varname>text</varname>, <varname>code</varname>, <varname>temp</varname>
    sowie <varname>date</varname> werden alle auf Standardwerten belassen, das
    Property <varname>weather</varname> ist mit der Kennzeichnung
    <classname>@OneToOne</classname> versehen sowie einer weiteren Annotation
    welche das entsprechende Objekt <classname>Weather</classname> mit dem
    Fremdschlüssel des Namens <varname>weather_id</varname> in Verbindung
    bringt.</para>
  </section>

  <section id="multimodule-web-spring-sect-simple-weather">
    <title>Das "Simple Weather" Modul - Die Dienste</title>

    <para>Das nächste Modul welches wir betrachten werden, ist so etwas wie
    ein "Dienst". Das "<varname>Simple Weather</varname>" Modul ist das Modul,
    das alle für den Abruf und die Analyse der Daten vom Yahoo! Wetter Dienst
    notwendige Logik enthält. Obwohl das "<varname>Simple Weather</varname>"
    Modul aus drei Java-Klassen und einem JUnit-Test besteht, stellt es eine
    einzige Komponente <classname>WeatherService</classname>, dar. Dieser wird
    sowohl durch "<varname>Simple Web</varname>" der Webapplikation, und auch
    "S<varname>imple Command</varname>" konsumiert. Häufig enthalten
    Enterprise Projekte ein oder mehrere API-Module welche kritische
    Business-Logik oder Logik zur Interaktion mit externen Systemen
    beinhalten. Ein Banken System könnten ein Modul beinhalten, welches Daten
    eines externen Providers abruft und analysiert; ein System zur Anzeige von
    Sportergebnisse könnte einen <acronym>XML</acronym>-Datenstrom verarbeiten
    um in Echtzeit die Ergebnisse von Basketball oder Fußball darzustellen. In
    unserem Beispiel kapselt dieses Modul alle notwendigen
    Netzwerk-Aktivitäten sowie das <acronym>XML</acronym>-Parsing zur
    Interaktion mit dem Yahoo! Wetter Dienst. Andere Module können auf dieses
    Modul aufbauen, Sie rufen einfach die Methode
    <methodname>retrieveForecast()</methodname> der Klasse
    <classname>WeatherService</classname> auf. Diese nimmt als Argument eine
    Postleitzahl und liefert ein Weather-Objekt zurück.</para>

    <example id="example_simple-weather_module_pom">
      <title>POM des simple-weather Moduls</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Weather API&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.14&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;dom4j&lt;/groupId&gt;
      &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
      &lt;version&gt;1.6.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;jaxen&lt;/groupId&gt;
      &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
      &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
      &lt;version&gt;1.3.2&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</programlisting>
    </example>

    <para>Das "<varname>Simple Weather</varname>" <acronym>POM</acronym>
    erweitert das darüberliegende (elterliche) <acronym>POM</acronym>, setzt
    das Packaging auf <varname>jar</varname> und fügt die folgenden
    Abhängigkeiten ein:</para>

    <variablelist>
      <varlistentry>
        <term><literal>org.sonatype.mavenbook.ch07:simple-model:1.0</literal></term>

        <listitem>
          <para>"<varname>Simple-Weather"</varname> analysiert den Yahoo!
          Wetter Dienst (<acronym>RSS</acronym>) und verpackt dieses in ein
          Objekt <classname>Weather</classname>. Es verfügt über eine direkte
          Abhängigkeit zum "<varname>Simple Model</varname>" Modul.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>log4j:log4j:1.2.14</literal></term>

        <listitem>
          <para>"<varname>Simple Weather</varname>" setzt auf die Bibliothek
          <productname>Log4J</productname> zum Ausgeben von Log-Nachrichten
          auf. </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>dom4j:dom4j:1.6.1 and
        jaxen:jaxen:1.1.1</literal></term>

        <listitem>
          <para>Diese Beide Abhängigkeiten sind notwendig um das vom Yahoo!
          Wetter Dienst zurückgegebene <acronym>XML</acronym> zu verarbeiten.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.apache.commons:commons-io:1.3.2
        (scope=test)</literal></term>

        <listitem>
          <para>Diese Abhängigkeit mit Gültigkeitsbereich
          <literal>test</literal> wird von der Klasse
          <classname>YahooParserTest</classname> benötigt.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Next is the <classname>WeatherService</classname> class, shown in
    <xref linkend="example_weatherservice_class" />. This class is going to
    look very similar to the <classname>WeatherService</classname> class from
    <xref linkend="multimodule-weather-service" />. Although the
    <classname>WeatherService</classname> is the same, there are some subtle
    differences in this chapter’s example. This version’s
    <methodname>retrieveForecast()</methodname> method returns a
    <classname>Weather</classname> object, and the formatting is going to be
    left to the applications that call <classname>WeatherService</classname>.
    The other major change is that the <classname>YahooRetriever</classname>
    and <classname>YahooParser</classname> are both bean properties of the
    <classname>WeatherService</classname> bean.</para>

    <para>Als nächstes betrachten wir die Klasse
    <classname>WeatherService</classname> (<xref
    linkend="example_weatherservice_class" />), diese Klasse ist sehr ähnlich
    zur Klasse <classname>WeatherService</classname> aus <xref
    linkend="multimodule-weather-service" /> (Beispiel 6.3: Die WeatherService
    Klasse). Während die Klasse <classname>WeatherService</classname> die
    Gleiche ist, gibt es in diesem Kapitel einige subtile Unterschiede des
    Beispiels zu beachten. Diese Version der Methode
    <methodname>retrieveForecast()</methodname> liefert ein Objekt
    <classname>Weather</classname> zurück und überlässt die Formatierung der
    aufrufenden Anwendungen. Die andere große Änderung ist, dass die Klassen
    <classname>YahooRetriever</classname> und
    <classname>YahooParser</classname> beide Bean Properties des Beans
    <classname>WeatherService</classname> sind.</para>

    <example id="example_weatherservice_class">
      <title>Die Klasse WeatherService</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStream;

import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherService {

  private YahooRetriever yahooRetriever;
  private YahooParser yahooParser;

  public WeatherService() {}

  public Weather retrieveForecast(String zip) throws Exception {
    // Daten holen
    InputStream dataIn = yahooRetriever.retrieve(zip);

    // Daten auswerten 
    Weather weather = yahooParser.parse(zip, dataIn);

    return weather;
  }

  public YahooRetriever getYahooRetriever() {
    return yahooRetriever;
  }

  public void setYahooRetriever(YahooRetriever yahooRetriever) {
    this.yahooRetriever = yahooRetriever;
  }

  public YahooParser getYahooParser() {
    return yahooParser;
  }

  public void setYahooParser(YahooParser yahooParser) {
    this.yahooParser = yahooParser;
  }
}
</programlisting>
    </example>

    <para>Schlussendlich haben wir in diesem Projekt eine
    <acronym>XML</acronym>-Datei. Diese wird vom Spring Framework benutzt, um
    den so genannten <classname><indexterm>
        <primary>ApplicationContext (Spring Framework)</primary>
      </indexterm>ApplicationContext</classname> zu erstellen. Zunächst einige
    Erläuterungen: unsere beiden Anwendungen, die Web-Anwendung und das
    Befehlszeilen-Dienstprogramm, müssen mit der Klasse
    <classname>WeatherService</classname> interagieren. Sie tun dies indem sie
    aus dem Spring <classname>ApplicationContext</classname> eine Instanz der
    Klasse mit dem Namen <classname>WeatherService</classname> holen. Unsere
    Web-Applikation, verwendet einen Spring <acronym>MVC</acronym>-Controller
    welcher einer Instanz des <classname>WeatherService</classname> zugeordnet
    ist, und unsere Dienstprogramm lädt die Klasse
    <classname>WeatherService</classname> von einem Spring
    <classname>ApplicationContext</classname> in einer statischen Methode
    <methodname>main()</methodname>. Um die Wiederverwendbarkeit zu fördern,
    haben wir unter <filename>/src/main/resources</filename> eine Datei
    <filename>applicationContext-weather.xml</filename> beigefügt, welche im
    Klassenpfad zur Verfügung steht. Module, welche eine Abhängigkeit zum
    "<varname>Simple Weather</varname>" Modul haben, können diesen Context mit
    dem <classname>ClasspathXmlApplicationContext</classname> des Spring
    Framework laden. Hierauf können Sie auf eine benannte Instanz der Klasse
    <classname>WeatherService</classname> namens
    <varname>weatherService</varname> zugreifen. </para>

    <example>
      <title>Spring Application Context fdes simple-weather Moduls</title>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    default-lazy-init="true"&gt;

    &lt;bean id="weatherService" 
             class="org.sonatype.mavenbook.weather.WeatherService"&gt;
      &lt;property name="yahooRetriever" ref="yahooRetriever"/&gt;
      &lt;property name="yahooParser" ref="yahooParser"/&gt;
    &lt;/bean&gt;    

    &lt;bean id="yahooRetriever" 
             class="org.sonatype.mavenbook.weather.YahooRetriever"/&gt;    

    &lt;bean id="yahooParser" 
             class="org.sonatype.mavenbook.weather.YahooParser"/&gt;
&lt;/beans&gt;</programlisting>
    </example>

    <para>Diese Konfiguration definiert drei Beans:
    <classname>yahooParser</classname>, <classname>yahooRetriever</classname>
    und <classname>weatherService</classname>. Das Bean
    <varname>weatherService </varname>ist eine Instanz von
    <classname>WeatherService</classname>, und das
    <acronym>XML</acronym>-Dokument belegt die Properties
    <varname>yahooParser</varname> und <varname>yahooRetriever</varname> mit
    Verweisen auf benannten Instanzen der entsprechenden Klassen. Sehen Sie in
    der Datei <filename>applicationContext-weather.xml</filename> die
    Definition der Architektur eines Teilsystems in diesem
    Multi-Modul-Projekt. Projekte wie "<varname>Simple Web</varname>" oder
    "<varname>Simple Command</varname>" können diesen Context referenzieren,
    und somit eine Instanz des <classname>WeatherService</classname> abrufen
    welcher bereits in Bezug zu Instanzen von
    <classname>YahooRetriever</classname> und
    <classname>YahooParser</classname> steht. </para>
  </section>

  <section id="multimodule-web-spring-sect-simple-persist">
    <title>Das "Simple Persist" Modul - Die Datenabstraktion</title>

    <para>Dieses Modul definiert zwei sehr einfache Daten Zugriffsobjekte
    (Data Access Objects: <acronym>DAO</acronym>). Ein <acronym>DAO</acronym>
    ist ein Objekt, das eine Schnittstelle für die Persistenz bereitstellt.
    </para>

    <para><note>
        <para>Warum Persistenz und nicht Speicherung? Persistenz ist der
        allgemeine Begriff, während Speicherung sich hinlänglich auf ein
        lokales Medium bezieht, was in keinem Fall gegeben sein muss.</para>
      </note></para>

    <para>In einer Anwendung welche auf Object-Relational-Mapping
    (<acronym>ORM</acronym>) Werkzeuge wie Hibernate zur Abbildung aufbaut,
    werden in der Regel <acronym>DAO</acronym>s um die zu persistierenden
    Objekte erstellt. In diesem Projekt definieren wir zwei DAO-Objekte:
    <classname>WeatherDAO</classname> und <classname>LocationDAO</classname>.
    Die Klasse <classname>WeatherDAO</classname> erlaubt es uns,
    Wetter-Objekte in einer Datenbank abzuspeichern bzw. Wetter-Objekte anhand
    eines Schlüssels (<varname>weatherId</varname>) oder auch zu einem
    bestimmten Standort abzurufen. Das <classname>LocationDAO</classname>
    besitzt eine Methode, welche es uns erlaubt zu einer gegebenen
    Postleitzahl das entspreche Standort-Objekt zu holen. Lassen Sie uns einen
    Blick auf die "<varname>Simple Persist</varname>" POM werfen: </para>

    <example id="ex-simple-persist-POM">
      <title>POM des "simple-persist" Moduls</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Persistence API&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
      &lt;version&gt;3.2.5.ga&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
          &lt;artifactId&gt;jta&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>Diese <acronym>POM</acronym>-Datei referenziert "<varname>Simple
    Parent</varname>" als darüberliegendes, elterliches
    <acronym>POM</acronym>, sowie eine Anzahl Abhängigkeiten. Im Rahmen des
    "<varname>Simple Persist</varname>" Moduls sind diese:</para>

    <variablelist>
      <varlistentry>
        <term><literal>org.sonatype.mavenbook.ch07:simple-model:1.0</literal></term>

        <listitem>
          <para>Genau wie bereits im "<varname>Simple Weather</varname>"
          Modul, wird hier eine Abhängigkeit zum grundlegenden Objekt Modell
          wie es in "<varname>Simple Model</varname>" definiert ist,
          beschrieben.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.hibernate:hibernate:3.2.5.ga</literal></term>

        <listitem>
          <para>Wir definieren eine Abhängigkeit zu
          <productname>Hibernate</productname> <productnumber>Version
          3.2.5.ga</productnumber>, aber wie Sie richtig bemerkt haben, wird
          eine (transitive) Abhängigkeit von Hibernate ausgeschlossen. Wir tun
          dies, da die Abhängigkeit <varname>javax.transaction:javax</varname>
          nicht im öffentlichen Maven-Repository verfügbar ist. Diese
          Abhängigkeit ist eine dieser Abhängigkeiten zu Sun Microsystems
          Quellcode, welche es noch nicht in die freien zentralen
          Maven-Repositories geschafft hat. Um zu verhindern, dass ein immer
          eine ärgerlicher Meldung uns auf den notwendigen Download dieser
          (unfreien) Abhängigkeit hinweist, schliessen wir diese einfach aus,
          und fügen eine neue Abhängigkeit hinzu ...</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>javax.servlet:servlet-api:2.4</literal></term>

        <listitem>
          <para>Da das Projekt ein Servlet beinhaltet, müssen wir das Servlet
          API version 2.4 einschliessen. </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.springframework:spring:2.0.7</literal></term>

        <listitem>
          <para>Dies umfasst das gesamte Spring Framework als Abhängigkeit
          <indexterm>
              <primary>Spring Framework</primary>
            </indexterm>. </para>

          <note>
            <para>Es ist generell besser, eine Abhängigkeit zu den Komponenten
            von Spring zu definieren, zu denen diese tatsächlich besteht. Das
            Spring Framework-Projekt kommt Ihnen hier sehr entgegen, indem es
            genau definierende Artefakte wie z.B.
            <classname>spring-hibernate3</classname> erschaffen hat.)</para>
          </note>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Warum sich von Spring abhängig machen? Bei der Integration von
    Hibernate, erlaubt uns der Einsatz von Spring Helfer-Klassen wie die
    Klasse <classname>HibernateDaoSupport </classname>auszunützen. Um Ihnen
    ein Beispiel dafür zu geben, was unter Einsatz des
    <classname>HibernateDaoSupport</classname> möglich ist, werfen Sie einen
    Blick auf den Quellcode für das <classname>WeatherDAO</classname>:</para>

    <example id="ex-persist-weatherdao-class">
      <title>WeatherDAO Klasse des "simple persist" Moduls</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.persist;

import java.util.ArrayList;
import java.util.List;

import org.hibernate.Query;
import org.hibernate.Session;
import org.springframework.orm.hibernate3.HibernateCallback;
import org.springframework.orm.hibernate3.support.HibernateDaoSupport;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherDAO extends HibernateDaoSupport<co id="coDef-hibDao-1"
          linkends="coRef-hibDao-2" /> {

    public WeatherDAO() {}

    public void save(Weather weather) {<co id="coDef-hibDao-2"
          linkends="coRef-hibDao-2" />
      getHibernateTemplate().save( weather );
    }

    public Weather load(Integer id) {<co id="coDef-hibDao-3"
          linkends="coRef-hibDao-3" />
      return (Weather) getHibernateTemplate().load( Weather.class, id);
    }

    @SuppressWarnings("unchecked")
    public List&lt;Weather&gt; recentForLocation( final Location location ) {
      return (List&lt;Weather&gt;) getHibernateTemplate().execute(
        new HibernateCallback() {<co id="coDef-hibDao-4"
          linkends="coRef-hibDao-4" />
        public Object doInHibernate(Session session) {
          Query query = getSession().getNamedQuery("Weather.byLocation");
          query.setParameter("location", location);
          return new ArrayList&lt;Weather&gt;( query.list() );
        }
      });
    }
}</programlisting>
    </example>

    <para>Das ist alles! Nein wirklich, das ist die gesamte Klasse mit welcher
    Sie neue Zeilen einfügen, anhand von Primärschlüsseln Werte suchen, oder
    auch alle Zeilen in der Weather-Tabelle finden welche eine Referenz auf
    einen Ort setzen. Sie werden verstehen, dass wir an dieser Stelle nicht
    einfach das Buch schliessen können um die notwendigen fünfhundert Seiten
    Erklärung der Feinheiten des Hibernate Frameworks einzuschieben, aber was
    wir tun können ist, Ihnen ein paar kurze Erklärungen geben: </para>

    <calloutlist>
      <callout arearefs="coDef-hibDao-1" id="coRef-hibDao-1">
        <para>Die Klasse leitet sich von
        <classname>HibernateDaoSupport</classname> ab. Das bedeutet, dass die
        Klasse mit einer Hibernate <classname>SessionFactory</classname>
        verbunden ist, welche zum Einsatz kommt Hibernate Session Objekte zu
        erstellen. In Hibernate wird jeder Aufruf über ein Session-Objekt
        ausgeführt. Eine Session vermittelt Zugang zu der zugrunde liegenden
        Datenbank und kümmert sich um die Verwaltung der Verbindung zur
        <acronym>JDBC</acronym>-Datenquelle. Die Erweiterung von
        <classname>HibernateDaoSupport</classname> bedeutet auch, dass wir
        Zugriff auf <classname>HibernateTemplates</classname> mittels
        <methodname>getHibernateTemplate()</methodname> haben. Um Ihnen ein
        Beispiel davon zu geben, was mit
        <classname>HibernateTemplates</classname> möglich ist ... </para>
      </callout>

      <callout arearefs="coDef-hibDao-2" id="coRef-hibDao-2">
        <para>...die Methode <methodname>save()</methodname> nimmt sich einer
        Instanz eines Wetter Objekts an, und ruft die Methode
        <methodname>save()</methodname> eines
        <classname>HibernateTemplate</classname> auf. Das
        <classname>HibernateTemplate</classname> verwandelt den Aufruf in
        einfache Hibernate Operationen um, und wandelt jegliche Datenbank
        spezifische Exeptions in entsprechende Runtime-Exceptions um. In
        diesem Fall rufen wir <methodname>save()</methodname> auf, um einen
        Datensatz in der Datenbank, in der Tabelle
        <classname>Weather</classname> abzulegen. Alternativen zu diesem
        Aufruf wären <methodname>update()</methodname> sollten wir einen
        Eintrag aktualisieren, oder <methodname>saveOrUpdate()</methodname>,
        welches den Datensatz entweder anlegt oder aktualisiert, abhängig von
        der Anwesenheit eines Properties <varname>id</varname> des Objekts
        Weather, das nicht Null sein darf.</para>
      </callout>

      <callout arearefs="coDef-hibDao-3" id="coRef-hibDao-3">
        <para>Die Methode <methodname>load()</methodname> ist ein weiterer
        Einzeiler, welcher lediglich eine Methode einer Instanz des
        <classname>HibernateTemplates</classname> aufruft. Die Methode
        <methodname>load()</methodname> des
        <classname>HibernateTemplates</classname> hat zwei Parameter eine
        Klasse sowie eine serialisierbares Objekt. In diesem Fall entspricht
        das serialisierbare Objekt dem Wert der <varname>id</varname> des
        Objekts <classname>Weather</classname> welches geladen werden soll.
        </para>
      </callout>

      <callout arearefs="coDef-hibDao-4" id="coRef-hibDao-4">
        <para>Diese letzte Methode
        <methodname>recentForLocation()</methodname> beruft sich auf ein
        <classname>NamedQuery</classname> das im Wetter-Objekt-Modell
        festgelegt wurde. Sollten Sie sich erinnern, wir haben im
        Wetter-Objekt-Modell eine Abfrage "<code>Weather.byLocation</code>" in
        der Form "<code>from Weather w where w.location = :location</code>"
        definiert. Wir Laden dieses <classname>NamedQuery</classname> mit
        einem Verweis auf ein Hibernate Session-Objekt in einem
        <classname>HibernateCallback</classname> der ausgeführt wird, indem
        die Methode <methodname>execute()</methodname> eines
        <classname>HibernateTemplate</classname> aufgerufen wird. In dieser
        Methode sehen Sie, wie wir die benannten Parameter mit dem Parameter
        des Aufrufs der Methode <methodname>recentForLocation()</methodname>
        bevölkern.</para>
      </callout>
    </calloutlist>

    <para>Now is a good time for some clarification.
    <classname>HibernateDaoSupport</classname> and
    <classname>HibernateTemplate</classname> are classes from the Spring
    Framework. They were created by the Spring Framework to make writing
    Hibernate <acronym>DAO</acronym> objects painless. To support this
    <acronym>DAO</acronym>, we’ll need to do some configuration in the
    <varname>simple-persist</varname> Spring
    <classname>ApplicationContext</classname> definition. The XML document
    shown in <xref linkend="ex-persist-spring" /> is stored in
    <filename>src/main/resources</filename> in a file named <filename
    role="keep-together">applicationContext-persist.xml</filename>.</para>

    <para>Es ist an der Zeit für einige Klarstellungen:
    <classname>HibernateDaoSupport</classname> und
    <classname>HibernateTemplate</classname> sind Klassen des
    <productname>Spring Framework</productname>. Sie wurden von den
    Entwicklern des Spring Framework bereitgestellt, um das Bearbeiten von
    Hibernate DAO-Objekte schmerzloser zu gestalten. Um dieses
    <acronym>DAO</acronym> zu unterstützen, müssen wir noch einige wenige
    Einstellungen in der Definition des Spring
    <classname>ApplicationContext</classname> von "<varname>Simple
    Persist</varname>" vornehmen. Das folgende <acronym>XML</acronym>-Dokument
    ist unter <filename>/src/main/resources</filename> in einer Datei mit dem
    Namen <filename>applicationContext-persist.xml</filename> abgelegt.</para>

    <example id="ex-persist-spring">
      <title>Spring Application Context Definition für das "simple-persist"
      Modul</title>

      <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
    default-lazy-init="true"&gt;

    &lt;bean id="sessionFactory"
class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
        &lt;property name="annotatedClasses"&gt;
            &lt;list&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Atmosphere&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Condition&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Location&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Weather&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Wind&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;props&gt;
                &lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt;
                &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt;
                &lt;prop key="hibernate.transaction.factory_class"&gt;
                  org.hibernate.transaction.JDBCTransactionFactory
                &lt;/prop&gt;
                &lt;prop key="hibernate.dialect"&gt;
                  org.hibernate.dialect.HSQLDialect
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.pool_size"&gt;0&lt;/prop&gt;
                &lt;prop key="hibernate.connection.driver_class"&gt;
                  org.hsqldb.jdbcDriver
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.url"&gt;
                  jdbc:hsqldb:data/weather;shutdown=true
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.username"&gt;sa&lt;/prop&gt;
                &lt;prop key="hibernate.connection.password"&gt;&lt;/prop&gt;
                &lt;prop key="hibernate.connection.autocommit"&gt;true&lt;/prop&gt;
                &lt;prop key="hibernate.jdbc.batch_size"&gt;0&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="locationDAO" 
             class="org.sonatype.mavenbook.weather.persist.LocationDAO"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="weatherDAO" 
             class="org.sonatype.mavenbook.weather.persist.WeatherDAO"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
 &lt;/beans&gt;</programlisting>
    </example>

    <para>Dieser ApplicationContext erreicht eine Anzahl verschiedener Dinge:
    zunächst wird ein <classname>SessionFactory</classname> Bean
    bereitgestellt, ein Bean von welchem die <acronym>DAO</acronym>s die
    Hibernate Session Objekte beziehen. Dieses Bean ist eine Instanz des
    <classname>AnnotatedServiceFactoryBean</classname> und wird mit einer
    Anzahl <varname>annotatedClasses</varname> bereitgestellt. Hier sei
    bemerkt, dass die Liste der bereitgestellten annotierten Klassen die Liste
    der Klassen darstellt, welche in unserem Modul "<varname>Simple
    Model</varname>" definiert wurden. Als nächstes wird die
    <classname>sessionFactory</classname> entsprechend einer Reihe von
    Hibernate Konfigurationseigenschaften (hibernateProperties) konfiguriert.
    In diesem Beispiel definieren die HibernateProperties eine Reihe von
    Einstellungen:</para>

    <variablelist>
      <varlistentry>
        <term><literal>hibernate.dialect</literal></term>

        <listitem>
          <para>Diese Einstellung definiert, welcher SQL-Dialekt für unsere
          Datenbank generiert wird. Da wir als Datenbank HSQLDB einsetzen, ist
          der gewählte Datenbank Dialekt
          <classname>org.hibernate.dialect.HSQLDialect</classname>. Hibernate
          unterstützt die SQL-Dialekte aller wichtigen Datenbank Systeme wie
          Oracle, MySQL, PostgreSQL und SQL Server.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>hibernate.connection.*</literal></term>

        <listitem>
          <para>In diesem Beispiel werden die
          <acronym>JDBC</acronym>-Verbindungsparameter aus der Spring
          Konfiguration heraus gesetzt. Unsere Anwendungen sind so
          konfiguriert, dass sie gegen eine HSQLDB unter dem Verzeichnis
          <filename>./data/weather</filename> arbeiten. In einer echten
          Enterprise Applikation ist es wahrscheinlicher, dass Sie die
          Datenbankkonfiguration mittles <acronym>JNDI</acronym>
          externalisieren und somit von Ihrem Quellcode trennen.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Schließlich werden in der Definitionsdatei der Bean die beiden
    <acronym>DAO</acronym>-Objekte des "<varname>Simple Persist</varname>"
    Moduls erstellt und mit einer Referenz auf die eben erstellte
    <classname>sessionFactory</classname> Bean versehen. Genau wie im Spring
    Applikations- Context von "<varname>Simple Weather</varname>" definiert
    diese Datei <filename>applicationContext-persit.xml</filename> die
    Architektur eines Submoduls einer grösseren Anwendung. Sollten Sie mit
    einer grösseren Anzahl von Persistenzklassen arbeiten, bietet es sich
    unter Umständen an, diese in einem eigenen
    <classname>applicationContext</classname> ausserhalb Ihrer Anwendung
    zusammenzufassen.</para>

    <para>There’s one last piece of the puzzle in
    <varname>simple-persist</varname>. Later in this chapter, we’re going to
    <indexterm>
        <primary>Maven Hibernate3 plugin</primary>
      </indexterm><indexterm>
        <primary>Hibernate3 plugin</primary>
      </indexterm>see how we can use the Maven Hibernate3 plugin to generate
    our database schema from the annotated model objects. For this to work
    properly, the Maven Hibernate3 plugin needs to read the
    <acronym>JDBC</acronym> connection configuration parameters, the list of
    annotated classes, and other Hibernate configuration from a file
    named<indexterm>
        <primary>hibernate.cfg.xml file</primary>
      </indexterm> <filename>hibernate.cfg.xml</filename> in
    <filename>src/main/resources</filename>. The purpose of this file (which
    duplicates some of the configuration in
    <filename>applicationContext-persist.xml</filename>) is to allow us to
    leverage the Maven Hibernate3 <phrase role="keep-together">plugin</phrase>
    to generate Data Definition Language (<acronym>DDL</acronym>) from nothing
    more than our annotations. See <xref linkend="ex-hibernate-cfg" />.</para>

    <para>Als letztes Puzzleteil des "<varname>Simple Persist</varname>"
    Beispiels werden wir später im Kapitel erfahren, wie wir mit der Hilfe des
    Hibernate3 Maven Plugins aus den annotierten Modellobjekten unser
    Datenbankschema erzeugen können. Damit dies funktioniert, muss das
    Hibernate3 Maven Plugin die Parameter der
    <acronym>JDBC</acronym>-Verbindungskonfiguration, die Liste der
    kommentierten Klassen und andere Hibernate-Konfigurations Parameter aus
    einer Datei mit dem Namen <filename>hibernate.cfg.xml</filename> unter
    <filename>/src/main/resources</filename> auslesen können. Der Zweck dieser
    Datei (welche einige Konfigurationen der
    <filename>applicationContext-persist.xml</filename> dupliziert) ist es,
    das Hibernate3 Maven Plugin so zu nutzen, dass wir aus nichts weiter als
    unseren annotierten Klassen die gesamte <acronym>DDL</acronym> erstellen
    können.</para>

    <example id="ex-hibernate-cfg">
      <title>hibernate.cfg.xml des "simple-persist" Moduls</title>

      <programlisting language="xml">&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;
        
&lt;hibernate-configuration&gt;
  &lt;session-factory&gt;
        
    &lt;!-- SQL Dialekt --&gt;
    &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;
    
    &lt;!-- Datenbank Verbindungsparamenter --&gt;
    &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
    &lt;property name="connection.url"&gt;jdbc:hsqldb:data/weather&lt;/property&gt;
    &lt;property name="connection.username"&gt;sa&lt;/property&gt;
    &lt;property name="connection.password"&gt;&lt;/property&gt;
    &lt;property name="connection.shutdown"&gt;true&lt;/property&gt;
    
    &lt;!-- JDBC connection pool (den gestellten pool benutzen) --&gt;
    &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;
    
    &lt;!-- Aktivierung des automatischen Hibernate Session Context Management --&gt;
    &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;
    
    &lt;!-- Deaktivierung des second Level Cache --&gt;
    &lt;property name="cache.provider_class"&gt;
      org.hibernate.cache.NoCacheProvider
    &lt;/property&gt;
    
    &lt;!-- Ausgabe allen SQL auf stdout --&gt;
    &lt;property name="show_sql"&gt;true&lt;/property&gt;
    
    &lt;!-- deaktivierung der Batch funktionalität von HSQLDB um Fehler korrekt weiterzugeben --&gt;
    &lt;property name="jdbc.batch_size"&gt;0&lt;/property&gt;
    
    &lt;!-- Auflisten aller bestehender Property Dateien --&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Atmosphere"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Condition"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Location"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Weather"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Wind"/&gt;
        
  &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</programlisting>
    </example>

    <para>Die Inhalte von <xref linkend="ex-persist-spring" /> (Beispiel 7.10:
    "'Simple Persist' Spring Application Context") und <xref
    linkend="ex-multimodule-web-spring-parent" /> (Beispiel 7.1: "Simple
    Parent POM Project" ) sind redundant. Während die Datei
    <filename>SpringApplicationContext.xml</filename> von der Web- sowie der
    Befehlszeilen-Anwendung benutzt wird, findet die Datei
    <filename>hibernate.cfg.xml</filename> nur Einsatz zur Unterstützung des
    Hibernate3 Maven Plugins. Später in diesem Kapitel werden wir sehen, wie
    man mittels der Datei <filename>hibernate.cfg.xml</filename> und dem
    Hibernate3 Maven Plugin ein Datenbank-Schema, basierend auf dem
    kommentierten Objektmodell wie dieses in "<varname>Simple Model</varname>"
    besteht, generieren kann. Es ist die Datei
    <filename>hibernate.cfg.xml</filename> welche die Eigenschaften der
    <acronym>JDBC</acronym>-Verbindung konfiguriert und die annotierten
    Modelklassen in form einer Aufzählung dem Hibernate3 Maven Plugin
    bereitstellt.</para>
  </section>

  <section id="multimodule-web-spring-sect-simple-web">
    <title>Das "Simple Web" Modul - Das Web-Interface</title>

    <para>Die Web-Anwendung wird in einem einfachen Web Applikations Projekt
    definiert. Dieses einfache Web Applikations Projekt definiert zwei Spring
    <acronym>MVC</acronym> Controller Objekte:
    <classname>WeatherController</classname> und
    <classname>HistoryController</classname>. Beide Controller werden auf
    Komponenten der "<varname>Simple Weather</varname>" und "<varname>Simple
    Persist</varname>" Module abgebildet. Der Spring Container wird in der zu
    dieser Applikation zugehörigen Datei <filename>web.xml</filename>
    konfiguriert. Diese referenziert die Datei
    <filename>applicationContext-weather.xml</filename> unter "<varname>Simple
    Weather</varname>" sowie die Datei
    <filename>applicationContext-persist.xml </filename>in "<varname>Simple
    Persist</varname>". Die Komponenten-Architektur von dieser einfachen
    Web-Anwendung ist in <xref linkend="fig-web-components" /> (Abbildung 7.3:
    "Abhängigkeiten des Spring MVC Controllers zu den Komponenten aus 'Simple
    Weather' sowie 'Simple Persist' ") dargestellt. </para>

    <figure id="fig-web-components">
      <title>Abhängigkeiten des Spring MVC Controllers zu den Komponenten aus
      'Simple Weather' sowie 'Simple Persist'</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figs/web/multimodule-web-web-spring.png"
                     scalefit="1" width="6in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Das POM des Moduls "Simple Webapp" wird unten aufgeführt:</para>

    <example id="example_pom-for-simple-webapp">
      <title>POM fder simple-webapp</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;simple-webapp&lt;/artifactId&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;
  &lt;name&gt;Simple Web Application&lt;/name&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt; <co id="coDef-spring-web-1" os="coRef-spring-web-1" />
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
      &lt;artifactId&gt;velocity&lt;/artifactId&gt;
      &lt;version&gt;1.5&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;finalName&gt;simple-webapp&lt;/finalName&gt;
    &lt;plugins&gt;
      &lt;plugin&gt; <co id="coDef-spring-web-2" linkends="coRef-spring-web-2" />
        &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
        &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;
        &lt;dependencies&gt;<co id="coDef-spring-web-3"
          linkends="coRef-spring-web-3" />
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;        
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; <co
          id="coDef-spring-web-4" linkends="coRef-spring-web-4" />
        &lt;artifactId&gt;hibernate3-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;components&gt;
            &lt;component&gt;
              &lt;name&gt;hbm2ddl&lt;/name&gt;
              &lt;implementation&gt;annotationconfiguration&lt;/implementation&gt; <co
          id="coDef-spring-web-5" linkends="coRef-spring-web-5" />
            &lt;/component&gt;
          &lt;/components&gt;
        &lt;/configuration&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;        
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>Mit dem fortschreiten des Buches werden Sie festellen, dass die
    Datei <filename>pom.xml</filename> an Länge gewinnt. In diesem POM werden
    wir vier Abhängigkeiten und zwei Plugins konfigurieren. Lassen Sie uns
    Schritt für Schritt das POM durchgehen und die für die Konfiguration
    wichtigen Punkte genauer erläutern:</para>

    <calloutlist>
      <callout arearefs="coDef-spring-web-1" id="coRef-spring-web-1">
        <para>Das "<varname>Simple Web</varname>" Applikationsmodul definiert
        vier Abhängigkeiten: die Servlet-Spezifikation 2.4, die
        "<varname>Simple Weather</varname>" Dienste, die "<varname>Simple
        Persist</varname>" Applikations-Bibliothek sowie das gesamte Spring
        Framework 2.0.7.</para>
      </callout>

      <callout arearefs="coDef-spring-web-2" id="coRef-spring-web-2">
        <para>Das Jetty Maven Plugin könnte nicht einfacher in dieses Projekt
        einzufügen sein: wir fügen einfach ein Plugin-Element, welches die
        entsprechenden Koordinaten <literal>groupId</literal> und
        <literal>artifactId</literal> setzt, ein. Die Tatsache, dass dieses
        Plugin so trivial zu konfigurieren ist bedeutet, dass die
        Plugin-Entwickler einen guten Dienst getan haben. Es wurden sinnvolle
        Standardwerte gesetzt, welche wir in den meisten Fällen nicht
        übersteuern müssen. Sollten Sie dennoch die Standardeinstellungen
        übersteuern wollen/müssen, so tun Sie dies indem Sie ein
        Konfigurationselement mit den entsprechenden Werten einfügen.</para>
      </callout>

      <callout arearefs="coDef-spring-web-3" id="coRef-spring-web-3">
        <para>In unserer Build Konfiguration werden wir das Hibernate3 Maven
        Plugin so konfigurieren, dass dieses gegen eine eingebettete Instanz
        einer HSSQL Datenbank läuft. Damit das Hibernate3 Maven Plugin auf die
        Datenbank zugreifen kann, muss diese einen Verweis auf die
        JDBC-Treiber der HSSQL-Datenbank im Klassenpfad bekommen. Um diese
        Abhängigkeit eines Plugins bereitzustellen, erklären wir diese direkt
        im Plugin-Element. Hier referenzieren wir
        <productname>hsqldb:hsqldb:1.8.0.7</productname>. Das Hibernate Plugin
        benötigt die JDBC-Treiber ebenfalls, um die Datenbank zu erstellen.
        Aus diesem Grund haben wir diese dort ebenfalls referenziert.</para>
      </callout>

      <callout arearefs="coDef-spring-web-4" id="coRef-spring-web-4">
        <para>Es ist hier im Hibernate Maven Plugin ist, wo dieses POM anfängt
        interessant zu werden: Im nächsten Abschnitt werden wir das Goal
        <literal>hbm2ddl</literal> ausführen, um die HSQLDB Struktur zu
        erstellen. In dieser Datei <filename>pom.xml </filename>schliessen wir
        ebenfalls eine Referenz auf die Version 2.0 des <literal>Hibernate3
        Maven Plugin</literal> von Codehouse MoJo ein.</para>
      </callout>

      <callout arearefs="coDef-spring-web-5" id="coRef-spring-web-5">
        <para>Das <literal>Hibernate3 Maven Plugin</literal> kann auf
        verschiedenerlei Wegen an die Hibernate Mapping Informationen
        gelangen; abhängig vom jeweiligen Einsatzszenario des Hibernate
        Plugins. Sollten sie <filename>Hibernate Mapping
        XML(.hbm.xml)-Dateien</filename> einsetzen und hätten vor,
        Modellklassen mit Hilfe des Goals <literal>hbmjava</literal> zu
        generieren, so würden Sie Ihre Implementierung auf
        <emphasis>configuration</emphasis> stellen. Würden Sie jedoch
        Hiberante3 einsetzen um eine bestehende Datenbank zu re-engineeren, um
        daraus die entsprechenden <filename>.hbm.xml Dateien</filename> zu
        generieren und die Klassen dann daraus abzuleiten, so würden Sie die
        Implementierung <emphasis>jdbcconfiguration</emphasis> wählen. In
        unserem Fall benutzen wir einfach ein annotiertes Objekt Modell um
        eine Datenbank zu generieren. In anderen Worten, wir haben bereits
        unser Hibernate Mapping, jedoch keine bestehende Datenbank. In diesem
        Fall ist wählen wir <emphasis>annotationconfiguration</emphasis>. Das
        Hiberante3 Maven Plugin wird unter <xref
        linkend="multimodule-web-spring-sect-spring-running-web" /> (Abschnitt
        7.7: "Aufrufen der Web-Anwendung") näher beleuchtet. </para>
      </callout>
    </calloutlist>

    <note>
      <para>Ein häufiger auftretender Fehler ist die Verwendung der
      <sgmltag>extensions</sgmltag>-Konfiguration um Abhängigkeiten von
      Plugins zu definieren. Wir raten von dieser Praxis dringend ab, denn
      dies kann dazu führen, dass Ihr Klassenpfad -neben anderen unschönen
      Nebeneffekten- projektweit "verschmutzt" wird. Außerdem wird in der
      Version 2.1 genau diese Funktionalität stark überarbeitet werden, was
      bedeutet, dass Sie hier in jedem Fall noch einmal Hand anlegen müssten.
      Die einzige "normale" Nutzung für <sgmltag>Extensions</sgmltag> ist die,
      eine neue Paketdefinition zu erstellen.</para>
    </note>

    <para>Nun werden wir uns den beiden Spring MVC Controllern und deren
    Konfiguration zuwenden. Beide dieser Controller beziehen sich auf Beans
    welche in "<varname>Simple Weather</varname>" bzw "<varname>Simple
    Persist</varname>" definiert wurden. </para>

    <example>
      <title>simple-webapp WeatherController</title>

      <programlisting language="java">package org.sonatype.mavenbook.web;

import org.sonatype.mavenbook.weather.model.Weather;
import org.sonatype.mavenbook.weather.persist.WeatherDAO;
import org.sonatype.mavenbook.weather.WeatherService;
import javax.servlet.http.*;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

public class WeatherController implements Controller {

  private WeatherService weatherService;
  private WeatherDAO weatherDAO;

  public ModelAndView handleRequest(HttpServletRequest request,
      HttpServletResponse response) throws Exception {

    String zip = request.getParameter("zip");
    Weather weather = weatherService.retrieveForecast(zip);
    weatherDAO.save(weather);
    return new ModelAndView("weather", "weather", weather);
  }

  public WeatherService getWeatherService() {
    return weatherService;
  }

  public void setWeatherService(WeatherService weatherService) {
    this.weatherService = weatherService;
  }

  public WeatherDAO getWeatherDAO() {
    return weatherDAO;
  }

  public void setWeatherDAO(WeatherDAO weatherDAO) {
    this.weatherDAO = weatherDAO;
  }
}</programlisting>
    </example>

    <para>Die Klasse WeatherController implementiert das Spring MVC Controller
    Interface, welches die Existenz einer Methode
    <methodname>handleRequest()</methodname> in der oben angegebenen Form
    vorschreibt. Wenn Sie das Innenleben dieser Methode betrachten, so werden
    Sie feststellen, dass diese die Methode
    <methodname>retrieveForecast()</methodname> der Instanzvariablen
    <varname>weatherService</varname> aufruft. Anders als im vorgehenden
    Beispiel in welchem die Klasse <classname>WeatherService</classname> durch
    ein Servlet instanziert wurde, ist
    <classname>weatherController</classname> ein Bean, mit einem
    <varname>weatherService</varname> Property. </para>

    <para>Es liegt in der Verantwortung des Spring IoC Containers die
    Verdrahtung der Komponennte <classname>weatherService</classname>
    bereitzustellen. Darüber hinaus werden Sie bemerkt haben, dass wir in
    dieser Implementierung auf den <classname>weatherFormatter</classname>
    verzichten, an dessen Statt geben wir das Objekt
    <classname>Weather</classname>, welches von
    <methodname>retrieveForecast()</methodname> zurückgegeben wird an den
    Konstruktor von <classname>ModelAndView</classname>. Die Klasse
    <classname>ModelAndView</classname> werden wir benutzen um Velocity
    Templates darzustellen, welche eine Referenz zu einer Variablen
    <varname>\${weather}</varname> halten. Das zugehörige Template
    <filename>weather.vm</filename> liegt unter
    <filename>/src/main/webapp/WEB-INF/vm</filename> abgelegt und wird in
    <xref linkend="ex-weather-vm" /> (Beispiel 7.14) ausgeführt. </para>

    <para>In the <classname>WeatherController</classname>, before we render
    the output of the forecast, we pass the <classname>Weather</classname>
    object returned by the <classname>WeatherService</classname> to the
    <methodname>save()</methodname> method on
    <classname>WeatherDAO</classname>. Here we are saving this
    <classname>Weather</classname> object—using Hibernate—to an HSQLDB
    database. Later, in <classname>HistoryController</classname>, we will see
    how we can retrieve a history of weather forecasts that were saved by the
    <classname>WeatherController</classname>.</para>

    <para>Innerhalb des <classname>WeatherController</classname>, geben wir
    das vom <classname>WeatherService</classname> zurückgegebene Objekt
    <classname>Weather</classname> an die Methode
    <methodname>save()</methodname> des <classname>WeatherDAO</classname>.
    Dort wird das Objekt <classname>Weather</classname> mit Hilfe von
    Hibernate in der HSQLDB abgespeichert. Später im
    <classname>HistoryController</classname> werden wir sehen wie man die
    Vergangenheit bezüglich einer Wettervorhersage welche von HSQLDB
    gespeichert wurde, zurückgeholen kann.</para>

    <example>
      <title>Die von WeatherController wiedergegebene Vorlage weather.vm
      </title>

      <programlisting id="ex-weather-vm" language="xml">&lt;b&gt;Derzeitiges Wetter von:
  \${weather.location.city}, \${weather.location.region}, 
  \${weather.location.country}&lt;/b&gt;&lt;br/&gt;
  
&lt;ul&gt;
  &lt;li&gt;Temperatur: \${weather.condition.temp}&lt;/li&gt;
  &lt;li&gt;Wetterlage: \${weather.condition.text}&lt;/li&gt;
  &lt;li&gt;Feuchtigkeit: \${weather.atmosphere.humidity}&lt;/li&gt;
  &lt;li&gt;Wind Chill Faktor: \${weather.wind.chill}&lt;/li&gt;
  &lt;li&gt;Datum: \${weather.date}&lt;/li&gt;
&lt;/ul&gt;
</programlisting>
    </example>

    <para>Die Syntax der Velocity Vorlagen ist einfach, Variablen werden durch
    vorangestelltes Dollarzeichen in geschwungenen Klammern markiert
    <varname>\${Variable}</varname>. Der Ausdruck zwischen den geschweiften
    Klammern verweist auf ein Property, oder ein Property eines Properties der
    Variable <varname>weather</varname>, welche durch den
    <classname>WeatherController</classname> an das Template weitergegeben
    wurde. </para>

    <para>Der <classname>HistoryController</classname> wird eingesetzt, um auf
    Prognosen aus der Vergangenheit zuzugreifen welche zuvor vom
    <classname>WeatherController</classname> angefragt wurden. Immer, wenn wir
    wieder eine Prognose mittels dem <classname>WeatherController</classname>
    abrufen, speichert der Controller das Objekt
    <classname>Weather</classname> mittels dem
    <classname>WeatherDAO</classname> in der Datenbank. Das
    <classname>WeatherDAO</classname> nutzt Hibernate um das Objekt
    <classname>Weather</classname> in eine Reihe von Zeilen zu zerlegen und in
    eine Anzahl in Relation stehende Datenbanktabellen abzuspeichern. Der
    <classname>HistoryController</classname> ist im <xref
    linkend="ex-spring-history" /> (Beispiel 7.15: "Simple Web"
    HistoryController) ausgeführt.</para>

    <example id="ex-spring-history">
      <title>simple-web HistoryController</title>

      <programlisting language="java">package org.sonatype.mavenbook.web;

import java.util.*;
import javax.servlet.http.*;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;
import org.sonatype.mavenbook.weather.model.*;
import org.sonatype.mavenbook.weather.persist.*;

public class HistoryController implements Controller {

  private LocationDAO locationDAO;
  private WeatherDAO weatherDAO;

  public ModelAndView handleRequest(HttpServletRequest request,
      HttpServletResponse response) throws Exception {
    String zip = request.getParameter("zip");
    Location location = locationDAO.findByZip(zip);
    List&lt;Weather&gt; weathers = weatherDAO.recentForLocation( location );

    Map&lt;String,Object&gt; model = new HashMap&lt;String,Object&gt;();
    model.put( "location", location );
    model.put( "weathers", weathers );

    return new ModelAndView("history", model);
  }

  public WeatherDAO getWeatherDAO() {
    return weatherDAO;
  }

  public void setWeatherDAO(WeatherDAO weatherDAO) {
    this.weatherDAO = weatherDAO;
  }

  public LocationDAO getLocationDAO() {
    return locationDAO;
  }

  public void setLocationDAO(LocationDAO locationDAO) {
    this.locationDAO = locationDAO;
  }
}</programlisting>
    </example>

    <para>Der <classname>HistoryController</classname> ist mit zwei in
    "<varname>Simple Persist</varname>" definierten
    <acronym>DAO</acronym>-Objekten verdrahtet. Dabei sind die
    <acronym>DAO</acronym>s Bean-Properties des
    <classname>HistoryControllers</classname>:
    <classname>WeatherDAO</classname> und <classname>LocationDAO</classname>.
    Die Aufgabe des <classname>HistoryController</classname> ist, eine Liste
    von <classname>Weather</classname> Objekten entsprechend einer bestimmten
    Postleitzahl zurückzugeben. Wenn das <classname>WeatherDAO</classname> ein
    Objekt <classname>Weather</classname> in die Datenbank speichert, so legt
    es nicht eine Postleitzahl ab, sonder es speichert zusätzlich eine
    Referenz auf ein Objekt <classname>Location</classname> welches an das
    Objekt <classname>Weather</classname> gebunden ist, wie in
    "<varname>Simple Model</varname>" definiert. Um eine Liste von
    <classname>Weather</classname>-Objekte abzurufen, ruft der
    <classname>HistoryController</classname> zunächst das Objekt
    <classname>Lokation</classname> auf, welches der Postleitzahl entspricht.
    Dies wird durch den Aufruf der Methode
    <methodname>findByZip()</methodname> des
    <classname>LocationDAO</classname> bewerkstelligt.</para>

    <para>Nachdem ein Objekt <classname>Lokation</classname> abgerufen wurde,
    versucht der <classname>HistoryController</classname> die vorgängigen
    <classname>Weather</classname> Objekte mit Referenz auf das Objekt
    <classname>Lokation</classname> abzurufen. Das Ergebnis, welches in in der
    Form <classname>List&lt;Weather&gt;</classname> besteht, wird dann in eine
    <classname>HashMap</classname> von zwei Variablen der Velocity Vorlage
    <filename>history.vm</filename> wie im <xref
    linkend="ex-spring-history-velocity" /> (Beispiel 7.16: "history.vm
    dargestellt vom HistoryController") dargestellt, umgewandelt.</para>

    <example>
      <title>history.vm dargestellt vom HistoryController</title>

      <programlisting id="ex-spring-history-velocity" language="java">&lt;b&gt;
Derzeitige Wetterlage von: \${location.city}, \${location.region}, \${location.country}
&lt;/b&gt;
&lt;br/&gt;
  
#foreach( $weather in $weathers )
  &lt;ul&gt;
    &lt;li&gt;Temperatur: $weather.condition.temp&lt;/li&gt;
    &lt;li&gt;Zustand: $weather.condition.text&lt;/li&gt;
    &lt;li&gt;Feuchtigkeit: $weather.atmosphere.humidity&lt;/li&gt;
    &lt;li&gt;Wind Chill Faktor: $weather.wind.chill&lt;/li&gt;
    &lt;li&gt;Datum: $weather.date&lt;/li&gt;
  &lt;/ul&gt;
#end
</programlisting>
    </example>

    <para>Die Vorlage <filename>history.vm</filename> is unter
    <filename>/src/main/webapp/WEB-INF/vm</filename> abgelegt und verweist auf
    die Variable <varname>location</varname> um Angaben zum Standort/Lokation
    der Prognose, welche vom <classname>WeatherDAO</classname> zurückgegeben
    wurde auszugeben. Diese Vorlage unterliegt einer Velocity
    Kontrollstruktur, <code>#foreach</code>, welche sicherstellt, dass durch
    alle Elemente der Variablen <varname>weathers</varname> geschlauft wird.
    Jedes Element in <varname>weathers</varname> wird einer Variable
    <varname>weather</varname> zugeordnet und mit der Vorlage welche sich
    zwischen <code>#foreach</code> und <code>#end</code> befindet, verknüpft
    und ausgegeben. </para>

    <para>You've seen these <classname>Controller</classname> implementations,
    and you've seen that they reference other beans defined in
    <varname>simple-weather</varname> and <varname>simple-persist</varname>,
    they respond to <acronym>HTTP</acronym> requests, and they yield control
    to some mysterious templating system that knows how to render Velocity
    templates. All of this magic is configured in a Spring application context
    in <filename>src/main/webapp/WEB-INF/weather-servlet.xml</filename>. This
    <acronym>XML</acronym> configures the controllers and references other
    Spring-managed beans, it is loaded by a
    <classname>ServletContextListener</classname> which is also configured to
    load the <filename>applicationContext-weather.xml</filename> and
    <filename>applicationContext-persist.xml</filename> from the classpath.
    Let's take a closer look at the <filename>weather-servlet.xml</filename>
    shown in <xref linkend="ex-spring-weather-servlet" />.</para>

    <para>Sie haben nun die Controller-Implementierung gesehen, und Sie haben
    gesehen, dass sich deren Implementierung auf weitere Beans welche in
    "<varname>Simple Weather</varname>" sowie "<varname>Simple
    Persist</varname>" definiert sind, stützt. Sie reagieren auf
    <acronym>HTTP</acronym>-Anfragen, und übernehmen die Kontrolle eines
    misteriösen Templating-Systems welches weiß, wie man Velocity-Vorlagen
    verarbeitet. Diese ganze Magie wurde im Spring
    <classname>applicationContext</classname> definiert, welcher sich unter
    <filename>/src/main/webapp/WEB-INF/weather-servlet.xml</filename>
    befindet. Diese <acronym>XML</acronym>-Konfiguration konfiguriert die
    Controller und definiert weitere Referenzen zu Beans welche von Spring
    verwaltet werden. die Datei <filename>weather-servlet.xml</filename> wird
    von einem <classname>ServletContextListener</classname> geladen, welcher
    zugleich so konfiguriert ist, dass er die Datei
    <filename>applicationContext-weather.xml</filename> sowie
    <filename>applicationContext-persist.xml</filename> vom Klassenpfad lädt.
    Lassen Sie uns die datei <filename>weather-servlet.xml</filename> einmal
    genauer anschauen.</para>

    <example>
      <title>Spring Controller Konfiguration weather-servlet.xml</title>

      <programlisting id="ex-spring-weather-servlet" language="xml">&lt;beans&gt;  
     &lt;bean id="weatherController" <co id="coDef-weather-servlet-1"
          linkends="coRef-weather-servlet-1" />
           class="org.sonatype.mavenbook.web.WeatherController"&gt;
       &lt;property name="weatherService" ref="weatherService"/&gt;
       &lt;property name="weatherDAO" ref="weatherDAO"/&gt;
     &lt;/bean&gt;

     &lt;bean id="historyController" 
           class="org.sonatype.mavenbook.web.HistoryController"&gt;
       &lt;property name="weatherDAO" ref="weatherDAO"/&gt;
       &lt;property name="locationDAO" ref="locationDAO"/&gt;
     &lt;/bean&gt;

     &lt;!-- Sie können mehr als einen Controller definieren  --&gt;
     &lt;bean id="urlMapping" 
     class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
          &lt;property name="urlMap"&gt;
               &lt;map&gt;
                    &lt;entry key="/weather.x"&gt; <co
          id="coDef-weather-servlet-2" linkends="coRef-weather-servlet-2" />
                         &lt;ref bean="weatherController" /&gt;
                    &lt;/entry&gt;
                    &lt;entry key="/history.x"&gt;
                         &lt;ref bean="historyController" /&gt;
                    &lt;/entry&gt;
               &lt;/map&gt;
          &lt;/property&gt;
     &lt;/bean&gt;


     &lt;bean id="velocityConfig" <co id="coDef-weather-servlet-3"
          linkends="coRef-weather-servlet-3" />
   class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
       &lt;property name="resourceLoaderPath" value="/WEB-INF/vm/"/&gt;
     &lt;/bean&gt;

     &lt;bean id="viewResolver" <co id="coDef-weather-servlet-4"
          linkends="coRef-weather-servlet-4" />
   class="org.springframework.web.servlet.view.velocity.VelocityViewResolver"&gt;
       &lt;property name="cache" value="true"/&gt;
       &lt;property name="prefix" value=""/&gt;
       &lt;property name="suffix" value=".vm"/&gt;
       &lt;property name="exposeSpringMacroHelpers" value="true"/&gt;
     &lt;/bean&gt;
&lt;/beans&gt;
</programlisting>
    </example>

    <calloutlist>
      <callout arearefs="coDef-weather-servlet-1" id="coRef-weather-servlet-1">
        <para>Die Datei <filename>weather-servlet.xml</filename> definiert die
        beiden Controller als Spring-verwaltete Beans.
        <classname>weatherController</classname> besitzt zwei Properties,
        welche Verweise auf <filename>weatherService</filename> und
        <filename>weatherDAO</filename> darstellen;
        <classname>historyController</classname> verweist auf die Beans
        <classname>weatherDAO</classname> und
        <classname>locationDAO</classname>. Wenn dieser
        <classname>ApplicationContext</classname> erstellt wird, so geschieht
        dies in einem Umfeld, welches den Zugang zu den
        <classname>ApplicationContexten</classname> definiert, sowohl zum
        "<varname>Simple Persist</varname>" wie auch zum "<varname>Simple
        Weather</varname>" Application Context. Im <xref
        linkend="ex-spring-webxml" /> Beispiel werden Sie sehen, wie man
        Spring konfigurieren kann, um mehrere Komponenten aus verschiedenen
        Spring Konfigurations-Dateien zusammenzuführen.</para>
      </callout>

      <callout arearefs="coDef-weather-servlet-2" id="coRef-weather-servlet-2">
        <para>Das Bean <classname>urlMapping</classname> definiert
        <acronym>URL</acronym>-Muster, welche den
        <classname>WeatherController</classname> und den
        <classname>HistoryController</classname> aufrufen. In diesem Beispiel
        benutzen wir <classname>SimpleUrlHandlerMapping</classname> und bilden
        <filename>/weather.x</filename> auf den
        <classname>WeatherController</classname> sowie
        <filename>/history.x</filename> auf den
        <classname>HistoryController</classname> ab.</para>
      </callout>

      <callout arearefs="coDef-weather-servlet-3" id="coRef-weather-servlet-3">
        <para>Da wir mit der Velocity-Templating-Engine arbeiten, sind wir
        gezwungen etliche Konfigurations-Optionen weiterzugeben. Hierzu weisen
        wir in der Datei <filename>velocityConfig.xml</filename> Velocity an,
        Vorlagen immer unter <filename>/WEB-INF/vm</filename> zu
        suchen.</para>
      </callout>

      <callout arearefs="coDef-weather-servlet-4" id="coRef-weather-servlet-4">
        <para>Zuletzt wird der <classname>viewResolver</classname> mit der
        Klasse <classname>VelocityViewResolver</classname> konfiguriert. Es
        gibt bereits eine Reihe von Implementierungen des
        <classname>ViewResolvers</classname> in Spring; diese reichen von
        einem Standard-ViewResolver um
        <acronym>JSTL</acronym>/<acronym>JSP</acronym>-Seiten zu generieren,
        und reicht bis zu solchen welcher Freemaker Templates erstellen
        können. In unserem Beispiel werden wir die Velocity-Templating-Engine
        konfigurieren, sowie die Standard-Präfix und Suffixe setzen, welche
        automatisch an die Namen der Vorlagen angefügt werden und an
        <classname>ModelAndView</classname> weitergegeben werden.</para>
      </callout>
    </calloutlist>

    <para>Finally, the <varname>simple-webapp</varname> project was a
    <filename>web.xml</filename> which provides the basic configuration for
    the web application. The <filename>web.xml</filename> file is shown in
    <xref linkend="ex-spring-webxml" />.</para>

    <para>Schließlich ist das "<varname>Simple Web</varname>" Projekt eine
    Webanwendung, und benötigt somit eine Datei <filename>web.xml</filename>
    als Basiskonfiguration der Anwendung. Die zugehörige Datei
    <filename>web.xml</filename> ist <xref linkend="ex-spring-webxml" />
    (7.18: "web.xml von 'Simple Web' ") wiedergegeben.</para>

    <example>
      <title>web.xml von 'Simple Web' </title>

      <programlisting id="ex-spring-webxml" language="xml">&lt;web-app id="simple-webapp" version="2.4" 
     xmlns="http://java.sun.com/xml/ns/j2ee" 
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
     xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee 
                         http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;
  &lt;display-name&gt;Simple Web Application&lt;/display-name&gt;
  
  &lt;context-param&gt; <co id="coDef-spring-webx-1"
          linkends="coRef-spring-webx-1" />
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;
      classpath:applicationContext-weather.xml
      classpath:applicationContext-persist.xml
    &lt;/param-value&gt;
  &lt;/context-param&gt;
  
  &lt;context-param&gt; <co id="coDef-spring-webx-2"
          linkends="coRef-spring-webx-2" />
    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt;
  &lt;/context-param&gt;
  
  &lt;listener&gt; <co id="coDef-spring-webx-3" linkends="coRef-spring-webx-3" />
    &lt;listener-class&gt;
      org.springframework.web.util.Log4jConfigListener
    &lt;/listener-class&gt;
  &lt;/listener&gt;
  
  &lt;listener&gt;
    &lt;listener-class&gt; <co id="coDef-spring-webx-4"
          linkends="coRef-spring-webx-4" />
     org.springframework.web.context.ContextLoaderListener
    &lt;/listener-class&gt;
  &lt;/listener&gt;
  
  &lt;servlet&gt; <co id="coDef-spring-webx-5" linkends="coRef-spring-webx-5" />
    &lt;servlet-name&gt;weather&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
      org.springframework.web.servlet.DispatcherServlet
    &lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  
  &lt;servlet-mapping&gt; <co id="coDef-spring-webx-6"
          linkends="coRef-spring-webx-6" />
    &lt;servlet-name&gt;weather&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.x&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</programlisting>
    </example>

    <calloutlist>
      <callout arearefs="coDef-spring-webx-1" id="coRef-spring-webx-1">
        <para>Hier ein kleines Kusntstück das uns die Wiederverwendung des
        <filename>applicationContext-weather.xml</filename> sowie
        <filename>applicationContest.persist.xml</filename> innerhalb dieses
        Projekts erlaubt. Die <varname>contextConfigLocation</varname> wird
        vom <classname>ContextLoaderListener</classname> zur Erstellung eines
        <classname>ApplicationContext</classname> benutzt. Beim Erstellen des
        Weather Servlets wird die Datei
        <filename>weather-servlet.xml</filename> -wie in <xref
        linkend="ex-spring-weather-servlet" /> (Beispiel 7.17: Spring
        Controller Konfiguration weather-servlet.xml) dargestellt - im
        Zusammenhang mit dem <classname>applicationContext</classname> welcher
        aus der <varname>contextConfigLocation</varname> geladen wird,
        ausgewertet. Auf diese Weise können Sie in einem anderen Projekt eine
        Anzahl Beans definieren und auf diese über den Klassenpfad zugreifen.
        Da sowohl "<varname>Simple Persist</varname>" als auch
        "<varname>Simple Weather</varname>" als JAR-Archiv unter
        <filename>/WEB-INF/lib</filename> verfügbar sein werden, müssen wir
        nur noch das Präfix <literal>classpath</literal>: benutzen, um diese
        Dateien zu referenzieren. (Eine andere Möglichkeit wäre gewesen, diese
        Dateien nach <filename>/WEB-INF</filename> zu kopieren, um sie dort
        mit einem Konstrukt wie etwa
        <filename>/WEB-INF/applicationContext-persist.xml</filename> zu
        referenzieren).</para>
      </callout>

      <callout arearefs="coDef-spring-webx-2" id="coRef-spring-webx-2">
        <para>Die <varname>log4jConfigLocation</varname> wird verwendet, um
        dem <classname>Log4JConfigListener</classname> mitzuteilen, wo dieser
        die Log4J Logging-Konfiguration finden kann. In diesem Beispiel weisen
        wir log4J an, unter <filename>/WEB-INF/log4j.properties</filename> zu
        suchen.</para>
      </callout>

      <callout arearefs="coDef-spring-webx-3" id="coRef-spring-webx-3">
        <para>Hiermit stellen wir sicher, dass das Log4J Subsystem
        konfiguriert ist, sobald die Web-Applikation gestartet wird. Es ist
        wichtig, den <classname>Log4JConfigListener</classname> vor dem
        <classname>ContextLoaderListener</classname> zu platzieren, da Sie
        anderenfalls unter Umständen wichtige Logging-Nachrichten verpassen,
        welche auf Probleme hinweisen können, die den ordungsgemässen Start
        der Anwendung verhindern. Insbesondere wenn Sie eine besonders große
        Anzahl Beans unter der Verwaltung von Spring haben, und eines der
        Beans beim Applikationsstart umfällt, wird Ihre Anwendung scheitern.
        Haben Sie dann bereits zuvor das Logging initialisiert, so haben Sei
        vielleicht die Möglichkeit eine Warnung oder eine Fehlermeldung
        aufzufangen; andernfalls werden Sie wohl keinerlei Ahnung haben warum
        Ihnen der Anwendungsstart misglückt ist.</para>
      </callout>

      <callout arearefs="coDef-spring-webx-4" id="coRef-spring-webx-4">
        <para>Der <classname>ContextLoaderListener</classname> ist im
        Wesentlichen der Spring Container. Beim Start einer Anwendung erstellt
        dieser Listner einen <classname>ApplicationContext</classname> aus dem
        Wert des <varname>contextConfigLocation</varname> Parameters.</para>
      </callout>

      <callout arearefs="coDef-spring-webx-5" id="coRef-spring-webx-5">
        <para>Wir definieren ein Spring <acronym>MVC</acronym>
        <classname>DispatcherServlet</classname> mit dem Namen
        <varname>weather</varname>. Hierdurch wird Spring unter
        <filename>/WEB-INF/weather-servlet.xml</filename> nach einer Spring
        Konfigurationsdatei suchen. Sie können so viele
        <classname>DispatcherServlets</classname> erstellen, wie Sie
        benötigen, ein <classname>DispatcherServlet</classname> kann eine oder
        mehrere Spring <acronym>MVC</acronym>-Controller-Implementierungen
        enthalten </para>
      </callout>

      <callout arearefs="coDef-spring-webx-6" id="coRef-spring-webx-6">
        <para>Alle in der Endung "<filename>.x</filename>" endenden Anfragen
        werden zum <classname>Weather Servlet </classname>geleitet. Wir
        möchten hier darauf hinweisen, dass die Endung
        "<filename>.x</filename>" keine tiefere Bedeutung hat, es ist eine
        willkürliche Auswahl welche Sie mit jedem beliebigen
        <acronym>URL</acronym>-Muster ersetzen können.</para>
      </callout>
    </calloutlist>
  </section>

  <section id="multimodule-web-spring-sect-spring-running-web">
    <title>Aufrufen der Web-Anwendung</title>

    <para>Um die Web-Anwendung aufrufen zu können müssen Sei zunächst mittels
    dem Hibernate3 Maven Plugin die Datenbank erstellen. Um dies zu tun, geben
    Sie bitte das folgende Kommando auf der Befehlszeile im Verzeichnis des
    "<varname>Simple Web</varname>" Projekts ein :</para>

    <screen>$ <command>mvn hibernate3:hbm2ddl</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'hibernate3'.
[INFO] org.codehaus.mojo: checking for updates from central
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Web Application
[INFO]    task-segment: [hibernate3:hbm2ddl]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing hibernate3:hbm2ddl
...
10:24:56,151  INFO org.hibernate.tool.hbm2ddl.SchemaExport - export complete
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
</screen>

    <para>Nach Abschluss der Ausführung sollte ein Verzeichnis
    <filename>\${basedir}/data</filename> erstellt sein welches die HSQLDB
    Datenbank enthält. Um die Web Applikation nun zu starten geben Sie
    folgenden Befehl ein: </para>

    <screen>$ <command>mvn jetty:run</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'jetty'.
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Web Application
[INFO]    task-segment: [jetty:run]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing jetty:run
...
[INFO] [jetty:run]
[INFO] Configuring Jetty for project: Chapter 7 Simple Web Application
...
[INFO] Context path = /simple-webapp
[INFO] Tmp directory =  determined at runtime
[INFO] Web defaults = org/mortbay/jetty/webapp/webdefault.xml
[INFO] Web overrides =  none
[INFO] Starting jetty 6.1.7 ...
2008-03-25 10:28:03.639::INFO:  jetty-6.1.7
...
2147 INFO  DispatcherServlet  - FrameworkServlet 'weather': \
           initialization completed in 1654 ms
2008-03-25 10:28:06.341::INFO:  Started SelectChannelConnector@0.0.0.0:8080
[INFO] Started Jetty Server
</screen>

    <para>Nach dem Start von Jetty, können Sie mit dem Aufruf <link
    linkend="???">http://localhost:8080/simple-webapp/weather.x?zip=60202</link>
    das Wetter von Evanston, IL aufrufen. Mit der Änderung der Postleitzahl
    sollte es Ihnen möglich sein Ihren eigenen Wetterbericht abzurufen.
    </para>

    <screen>Derzeitige Wetterlage von: Evanston, IL, US

    * Temperatur: 42
    * Zustand: Partly Cloudy
    * Feuchtigkeit: 55
    * Wind Chill Faktor: 34
    * Datum: Tue Mar 25 10:29:45 CDT 2008
</screen>
  </section>

  <section id="multimodule-web-spring-sect-simple-command">
    <title>Das "Simple Command" Modul - Das Kommandozeilen Modul</title>

    <para>Das "<varname>Simple Command</varname>" Modul ist die
    Befehlszeilen-Version der "<varname>Simple Web</varname>" Anwendung. Es
    ist ein Dienstprogramm, das auf den selben Abhängigkeiten aufbaut:
    "<varname>Simple Weather</varname>" und "<varname>Simple
    Persist</varname>". Statt der Interaktion über einen Web-Browser, rufen
    Sie für diese Anwendung ein Dienstprogramm
    <classname>'simple-command'</classname> von der Befehlszeile aus
    auf.</para>

    <figure>
      <title>Dienstprogramm aufbauend auf die Modue Simple-Weather und
      Simple-Persist</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figs/web/multimodule-web-command-spring.png"
                     scalefit="1" width="6in" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>POM des Simple-Command Moduls</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;simple-command&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;Simple Command Line Tool&lt;/name&gt;

  &lt;build&gt;
    &lt;finalName&gt;\${project.artifactId}&lt;/finalName&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.5&lt;/source&gt;
          &lt;target&gt;1.5&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
       &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
          &lt;/descriptorRefs&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate3-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
        &lt;configuration&gt;
          &lt;components&gt;
            &lt;component&gt;
              &lt;name&gt;hbm2ddl&lt;/name&gt;
              &lt;implementation&gt;annotationconfiguration&lt;/implementation&gt;
            &lt;/component&gt;
          &lt;/components&gt;
        &lt;/configuration&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;           
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;hsqldb&lt;/groupId&gt;
      &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
      &lt;version&gt;1.8.0.7&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>Dieses <acronym>POM</acronym> wird die Erstellung eines
    <acronym>JAR</acronym> files veranlassen, welches die Klasse
    <classname>org.sonatype.mavenbook.weather.Main</classname> beinhaltet.
    Diese Klasse wird in <xref linkend="ex-spring-command-main-class" />
    (Beispiel 7.20:"Klasse Main des Simple-Command Moduls" dargestellt. In
    dieser <filename>pom.xml</filename>-Datei werden wir das Maven Plugin
    Assembly um einen bereits mitgelieferten "Assembly Beschrieb" mit dem
    Namen "<varname>jar-with-dependencies</varname>" konfigurieren. Dieses
    Plugin wird sodann ein <acronym>JAR-</acronym> Archive erstellen, welches
    allen Bytecode beinhaltet welcher gebraucht wird, um das Projekt
    auszuführen, wie auch alle weitergehenden Abhängigkeiten.</para>

    <example id="ex-spring-command-main-class">
      <title>Klasse Main des Simple-Command Moduls</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.util.List;

import org.apache.log4j.PropertyConfigurator;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;
import org.sonatype.mavenbook.weather.persist.LocationDAO;
import org.sonatype.mavenbook.weather.persist.WeatherDAO;

public class Main {

  private WeatherService weatherService;
  private WeatherDAO weatherDAO;
  private LocationDAO locationDAO;

  public static void main(String[] args) throws Exception {
    // Configure Log4J
    PropertyConfigurator.configure(Main.class.getClassLoader().getResource(
        "log4j.properties"));

    // Read the Zip Code from the Command-line (if none supplied, use 60202)
    String zipcode = "60202";
    try {
      zipcode = args[0];
    } catch (Exception e) {
    }

    // Read the Operation from the Command-line (if none supplied use weather)
    String operation = "weather";
    try {
      operation = args[1];
    } catch (Exception e) {
    }

    // Start the program
    Main main = new Main(zipcode);

    ApplicationContext context = 
      new ClassPathXmlApplicationContext(
        new String[] { "classpath:applicationContext-weather.xml",
                       "classpath:applicationContext-persist.xml" });
    main.weatherService = (WeatherService) context.getBean("weatherService");
    main.locationDAO = (LocationDAO) context.getBean("locationDAO");
    main.weatherDAO = (WeatherDAO) context.getBean("weatherDAO");
    if( operation.equals("weather")) {
      main.getWeather();
    } else {
      main.getHistory();
    }
  }

  private String zip;

  public Main(String zip) {
    this.zip = zip;
  }

  public void getWeather() throws Exception {
    Weather weather = weatherService.retrieveForecast(zip);
    weatherDAO.save( weather );
    System.out.print(new WeatherFormatter().formatWeather(weather));
  }

  public void getHistory() throws Exception {
    Location location = locationDAO.findByZip(zip);
    List&lt;Weather&gt; weathers = weatherDAO.recentForLocation(location);
    System.out.print(new WeatherFormatter().formatHistory(location, weathers));
  }
}
</programlisting>
    </example>

    <para>Die Klasse Main hält eine Referenz auf die Klassen
    <classname>WeatherDAO</classname>, <classname>LocationDAO</classname> und
    <classname>WeatherService</classname>. Folgende Aufgaben werden durch
    deren statische Methode <methodname>main()</methodname> wahrgenommen:
    </para>

    <itemizedlist>
      <listitem>
        <para>Die Postleitzahl aus dem ersten Argument ([0]) der Befehlszeile
        auslesen </para>
      </listitem>

      <listitem>
        <para>Das Kommando aus dem zweiten Argument ([1]) der Befehlszeile
        auslesen. Ist das Kommando "weather", so werden die aktuellen
        Wetterdaten vom Webservice angefragt. Ist das Kommando
        "<emphasis>history</emphasis>" so werden die Wetterdaten aus der
        lokalen Datenbank abgerufen. </para>
      </listitem>

      <listitem>
        <para>Laden des Spring ApplicationContext unter Bezug auf zwei XML
        Dateien, welche von den Modulen "<varname>Simple Persist</varname>"
        und "<varname>Simple Weather</varname>" geladen wurden.</para>
      </listitem>

      <listitem>
        <para>Instanzieren der Klasse <classname>Main</classname></para>
      </listitem>

      <listitem>
        <para>Befruchten von <classname>WeatherService</classname>,
        <classname>WeatherDAO</classname> sowie
        <classname>LocationDAO</classname> mit Beans aus dem Spring
        <classname>ApplicationContext</classname> </para>
      </listitem>

      <listitem>
        <para>Aufrufen der entsprechenden Methode
        <methodname>getWeather()</methodname> oder
        <methodname>getHistory()</methodname> entsprechend dem übergebenen
        Kommando</para>
      </listitem>
    </itemizedlist>

    <para>Als Teil der Web Applikation benutzen wir Spring
    <classname>VelocityViewResolver</classname> um eine Velocity Vorlage
    darzustellen. Für die befehlszeilenorientierte Applikation ist es
    notwendig eine einfache Klasse zu erstellen, welche unsere Wetterdaten mit
    Hilfe einer Velocity Vorlage darstellt. <xref
    linkend="ex-spring-weather-formatter" /> (Beispiel 7.21:
    "<classname>WeatherFormatter</classname> stellt Wetterdaten unter Einbezug
    einer Velocity Vorlage dar") ist der Auszug der Klasse
    <classname>WeatherFormatter</classname>, einer Klasse mit zwei Methoden
    welche den Wetterbericht und die Wettergeschichte darstellen.</para>

    <example id="ex-spring-weather-formatter">
      <title><classname>WeatherFormatter</classname> stellt Wetterdaten unter
      Einbezug einer Velocity Vorlage dar</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.util.List;

import org.apache.log4j.Logger;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherFormatter {

  private static Logger log = Logger.getLogger(WeatherFormatter.class);

  public String formatWeather( Weather weather ) throws Exception {
    log.info( "Formatting Weather Data" );
    Reader reader = 
      new InputStreamReader( getClass().getClassLoader().
                                 getResourceAsStream("weather.vm"));
    VelocityContext context = new VelocityContext();
    context.put("weather", weather );
    StringWriter writer = new StringWriter();
    Velocity.evaluate(context, writer, "", reader);
    return writer.toString();
  }

  public String formatHistory( Location location, List&lt;Weather&gt; weathers )  
        throws Exception {
    log.info( "Formatting History Data" );
    Reader reader = 
      new InputStreamReader( getClass().getClassLoader().
                                 getResourceAsStream("history.vm"));
    VelocityContext context = new VelocityContext();
    context.put("location", location );
    context.put("weathers", weathers );
    StringWriter writer = new StringWriter();
    Velocity.evaluate(context, writer, "", reader);
    return writer.toString();
  }
}
</programlisting>
    </example>

    <para>Die Vorlage <filename>weather.vm</filename> gibt die zugehörige
    Stadt, den Staat, die Region sowie die aktuelle Temperatur aus. Die
    Vorlage <filename>history.vm</filename> gibt die Örtlichkeit aus, und
    iteriert dann über alle gespeicherten Wetterwerte der lokalen Datenbank.
    Diese beiden Vorlagen befinden sich unter
    <filename>\${basedir}/src/main/resource</filename>.</para>

    <example>
      <title>Die velocity Vorlage weather.vm</title>

      <programlisting language="java">****************************************
Current Weather Conditions for:
  \${weather.location.city},
  \${weather.location.region},
  \${weather.location.country}
****************************************

 * Temperature: \${weather.condition.temp}
 * Condition: \${weather.condition.text}
 * Humidity: \${weather.atmosphere.humidity}
 * Wind Chill: \${weather.wind.chill}
 * Date: \${weather.date}
</programlisting>
    </example>

    <example>
      <title>Die Velocity Vorlage history.vm</title>

      <para><programlisting>Weather History for:
\${location.city},
\${location.region},
\${location.country}


#foreach( $weather in $weathers )
****************************************
 * Temperature: $weather.condition.temp
 * Condition: $weather.condition.text
 * Humidity: $weather.atmosphere.humidity
 * Wind Chill: $weather.wind.chill
 * Date: $weather.date
#end</programlisting></para>
    </example>
  </section>

  <section id="multimodule-web-spring-sect-running-simple-command">
    <title>Aufrufen der Kommandozeilen-Anwendung</title>

    <para>Das Projekt Modul <varname>simple-command</varname> ist
    konfiguriert, ein einziges JAR Archiv, welches den Bytecode des Projektes
    sowie aller Bytecode der Abhängigkeiten enthält, zu erstellen. Um diese
    Baueinheit (Assembly) zu erzeugen, rufen Sie das Goal
    <varname>assembly</varname> des Maven Assembly Plugin von innerhalb des
    Verzeichnisses des Projektes <varname>"Simple Command"</varname> auf:
    </para>

    <screen>$ <command>mvn assembly:assembly</command>
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Command Line Tool
[INFO]    task-segment: [assembly:assembly] (aggregator-style)
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Nothing to compile - all classes are up to date
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Nothing to compile - all classes are up to date
[INFO] [surefire:test]
...
[INFO] [jar:jar]
[INFO] Building jar: .../simple-parent/simple-command/target/simple-command.jar
[INFO] [assembly:assembly]
[INFO] Processing DependencySet (output=)
[INFO] Expanding: .../.m2/repository/.../simple-weather-1-SNAPSHOT.jar into \
                                                        /tmp/archived-file-set.93251505.tmp
[INFO] Expanding: .../.m2/repository/.../simple-model-1-SNAPSHOT.jar into \
                                                        /tmp/archived-file-set.2012480870.tmp
[INFO] Expanding: .../.m2/repository/../hibernate-3.2.5.ga.jar into \
                                                        /tmp/archived-file-set.1296516202.tmp
... skipping 25 lines of dependency unpacking ...
[INFO] Expanding: .../.m2/repository/.../velocity-1.5.jar into /tmp/archived-file-set.379482226.tmp
[INFO] Expanding: .../.m2/repository/.../commons-lang-2.1.jar into \
                                                        /tmp/archived-file-set.1329200163.tmp
[INFO] Expanding: .../.m2/repository/.../oro-2.0.8.jar into /tmp/archived-file-set.1993155327.tmp
[INFO] Building jar: .../simple-parent/simple-command/target/simple-command-jar-with-dependencies.jar
</screen>

    <para>Der Build schreitet durch die Lebenszyklusphasen Kompilieren des
    Bytecodes, Aufrufen der Tests und schliesslich Erstellen des JAR-Archives.
    Zuletzt erstellt das Goal <varname>assembly:assembly</varname> ein
    einziges JAR Archiv inklusive aller Abhängigkeiten, indem es allen
    abhängigen Bytecode in temporäre Verzeichnisse entpackt um diesen
    schliesslich in einem einzigen JAR Archiv zusammenzufassen und im
    Zielverzeichnis <filename>/target</filename> unter dem Namen
    <filename>simple-command-jar-with-dependencies.jar</filename> abzulegen.
    Dieses "über" JAR Archiv kommt auf stolze 15 MB. </para>

    <para>Vor Sie nun das kommandozeilenorientierte Programm aufrufen, müssen
    Sie noch das Goal <varname>hbm2ddl</varname> des Maven Hibernate3 Plugin
    aufrufen, um die HSQL Datenbank zu erstellen. Sie tun dies, indem Sie den
    folgenden Befehl innerhalb des Verzeichnisses von "<varname>Simple
    Command</varname>" absetzen: </para>

    <para><screen>$ <command>mvn hibernate3:hbm2ddl</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'hibernate3'.
[INFO] org.codehaus.mojo: checking for updates from central
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Command Line Tool
[INFO]    task-segment: [hibernate3:hbm2ddl]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing hibernate3:hbm2ddl
...
10:24:56,151  INFO org.hibernate.tool.hbm2ddl.SchemaExport - export complete
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
</screen></para>

    <para>Nach dem Aufruf sollten Sie innerhalb des "<varname>Simple
    Command</varname>" Verzeichnisses ein Verzeichnis
    <filename>/data</filename> vorfinden. Dieses Verzeichnis beinhaltet die
    HSQL Datenbank. Um nun das befehlszeilenorientierte Programm aufzurufen,
    setzen Sie den folgenden Befehl von innerhalb des "<varname>Simple
    Command</varname>" Verzeichnisses ab: </para>

    <screen>$ <command>java -cp target/simple-command-jar-with-dependencies.jar \
           org.sonatype.mavenbook.weather.Main 60202</command>
2321 INFO  YahooRetriever  - Retrieving Weather Data
2489 INFO  YahooParser  - Creating XML Reader
2581 INFO  YahooParser  - Parsing XML Response
2875 INFO  WeatherFormatter  - Formatting Weather Data
****************************************
Current Weather Conditions for:
  Evanston, 
  IL, 
  US
****************************************
  
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: Wed Aug 06 09:35:30 CDT 2008
</screen>

    <para>Um eine Abfrage der vergangenen Werte abzusetzen, geben Sie den
    folgenden Befehl ein: </para>

    <screen>$ <command>java -cp target/simple-command-jar-with-dependencies.jar \
           org.sonatype.mavenbook.weather.Main 60202 history</command>
2470 INFO  WeatherFormatter  - Formatting History Data
Weather History for: 
Evanston, IL, US
  
****************************************
 * Temperature: 39
 * Condition: Heavy Rain
 * Humidity: 93
 * Wind Chill: 36
 * Date: 2007-12-02 13:45:27.187
****************************************
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: 2008-08-06 09:24:11.725
****************************************
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: 2008-08-06 09:27:28.475 </screen>
  </section>

  <section id="multimodule-web-spring-sect-conclusion">
    <title>Fazit</title>

    <para>Nun, wir haben viel Zeit damit verbracht, uns Themen anzunehmen,
    welche nicht im Zusammenhang mit Maven stehen. Wir haben dies getan, um
    ein vollständiges und aussagekräftiges Beispielprojekt mit Bezug zur
    realen Welt zu implementieren. Wir haben uns keine schnellen Abkürzungen
    geleistet, um Ihnen ein hochglanzpoliertes fix fertiges Produkt zu
    liefern. Auch war unser Ziel nicht, Sie mit einer Ruby on Rails artigen
    Zauberei zur Annahme zu führen, dass Sie nun in wenigen Minuten eine
    fix-fertige Java-Enterprise-Anwendung hinstellen könnten. - Hiervon gibt
    es bereits zu viele Beispiel im Markt, zu viele Menschen welche Ihnen das
    einfachste, umfassenste Framework zu verkaufen versuchen, welches Ihnen
    erlaubt mit Null Investition von Zeit und Aufmerksamkeit weiterzukommen.
    Unser Ziel diese Kapitels war es, Ihnen ein umfassendes Bild zu
    vermitteln: das gesamte Ökosystem eines Multi-Modul Projekt Builds. Was
    wir bieten ist Maven im Rahmen einer Anwendung einer Art ähnlich deren,
    welche Sie in freier Wildbahn antreffen, darzustellen. Es ist nicht unsere
    Art Ihnen eine Art Fast-Food anzubieten: 10 Minuten Bildschirm Show, etwas
    Schlamm in die Richtung Apache Ant geworfen und Sie davon überzeugt haben
    Maven einzusetzen!</para>

    <para>Sollten Sie sich nach dem Lesen dieses Kapitels fragen, was es mit
    Maven zu tun hat, so waren wir erfolgreich. Wir haben eine Reihe von
    komplex vernetzten Projekten, unter Einsatz von populären Frameworks
    erzeugt, und wir haben diese unter Verwendung von deklarativen Methoden
    verbunden. Die Tatsache, dass mehr als 60% dieses Kapitel der Erklärung
    von Spring und Hibernate gewidment wurde, sollte Ihnen aufzeigen, dass
    Maven grösstenteils zurücksteht. Es funktionierte einfach. Es erlaubt uns,
    uns auf die Anwendung selbst zu konzentrieren, und nicht so sehr auf der
    Build-Prozess. Sie werden bemerken, dass haben wir ein Projekt erstellt
    haben, welches Daten in einer Datenbank speichert, ohne ein einziges
    SQL-Statement abzusetzen. Daraufhin haben Sie eine Web-Anwendung erstellt,
    ohne sich mit den Erstellung eines Build Skriptes inklusive 20 plus
    Abhängigkeiten herumzuschlagen um am Ende ein WAR-Archiv zu erstellen.
    Anstelle Zeit damit zu verbringen Maven zu diskutieren, verbrachten wir
    die Zeit damit Spring und Hiberante in den Grundzügen einzuführen.</para>

    <para>Sie können das eingeführte Skelett Projekt dieses Kapitels als
    Grundlage für Ihre eigene Projekte verwenden, und die Chancen stehen gut,
    dass, sollten Sie das tun, Sie sich in der Lage befinden über die Zeit
    hinweg mehr und mehr Module nach Bedarf anzulegen. So umfasst das
    ursprüngliche Projekt, auf welchem dieses Beispiel beruht zwei
    verschiedene Modell-Projekte, mit zwei Persistenzprojekten welche den
    Anschuss an völlig unterschiedliche Datenbanksysteme übernehmen, mehrere
    Web-Applikationen, sowie eine Java-Mobil Anwendung. Insgesamt stützt sich
    das reale Welt-System auf mindestens 15 miteinander verknüpften Module.
    Was wir hiermit sagen wollen ist, Sie haben soeben das komplexeste
    Beispiel welches in diesem Buch dargestellt wird gesehen, aber Sie sollten
    auch wissen, dass dieses Beispiel nur Kratzer an der Oberfläche dessen was
    mit Maven möglich ist, darstellt. </para>

    <section id="multimodule-web-spring-sect-interface-projects">
      <title>Programmierung gegen Interface-Projekte</title>

      <para>Dieses Kapitel stieg in die Tiefe der Multi-Modul-Projekte hinab
      und war komplexer als die einfachen Beispiele in <xref
      linkend="multimodule" /> (Kapitel 6: Ein Multi-Projekt-Modul), und
      dennoch war es eine starke Vereinfachung eines Reale- Welt-Projektes. In
      einem größeren Projekt finden Sie vielleicht sogar selbst ein System
      ähnlich <xref linkend="fig-multimodule-web-spring-projects-complex" />
      (Abbildung 7.5) wieder. </para>

      <figure id="fig-multimodule-web-spring-projects-complex">
        <title>Programmierung gegen Interface-Projekte</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/multimodule-web-spring_projects-complex.png"
                       scalefit="1" width="7in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Wenn wir den Begriff <emphasis>Interface Projekt</emphasis>
      benutzen, so beziehen wir uns auf ein Maven Projekt, welches einzig aus
      Interfaces und Konstanten besteht. In <xref
      linkend="fig-multimodule-web-spring-projects-complex" /> (Abbildung 7.5
      Programmierung gegen ein Interface Projekt), stellen die Einheiten
      <varname>persist-api</varname> sowie <varname>parse-api</varname>
      Interfaceprojekte dar. Sollten <varname>big-command</varname> sowie
      <varname>big-webapp</varname> gegen diese Interface Projekte
      programmiert werden, ist es ein leichtes zu einem späteren Zeitpunkt die
      Implementierung der Persistenz gegen eine andere auszutauschen. Auf
      dieser Abbildung werden zwei Implementierungen dargestellt: eine welche
      die Persistenz aufbauend auf einen XML-Store implementiert, sowie einer
      weiteren auf der Basis einer relationalen Datenbank. Bei der Anwendung
      der in diesem Kapitel vorgestellten Konzepte ist es einfach zu sehen,
      wie Sie, getrieben durch einen an das Programm übergebenen Wert, eine
      andere Spring ApplicationContext XML Datei übergeben, um damit die
      unterliegende Persistenzimplementierung auszutauschen. Wie bereits im
      OO-Design der Applikation, ist oftmals sinnvoll das Interface einer API
      von der Implementierung einer API in seperate Maven Projekte
      aufzutrennen. </para>
    </section>
  </section>
</chapter>
