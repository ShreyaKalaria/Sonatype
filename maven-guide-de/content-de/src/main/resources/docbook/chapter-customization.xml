<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="customizing">
  <title>Anpassen eines Maven Projektes</title>

  <section id="customizing-sect-intro">
    <title>Einleitung </title>

    <para>Dieses Kapitel baut auf das vorangehende Kapitel (3), insbesondere
    auf das eingeführte "Simple Maven Projekt" auf. Wir erstellen mit dem
    Archetype Maven Plugin ein einfaches Projekt, fügen einige Abhängigkeiten
    ein, erstellen Quellcode und passen das Projekt unseren Bedürfnissen an.
    Am Ende dieses Kapitels, werden Sie wissen, wie man es am besten angeht,
    reale Projekte mit Maven zu erstellen.</para>

    <section id="customizing-sect-downloading">
      <title>Herunterladen der Beispiele dieses Kapitels</title>

      <para>In diesem Kapitel werden wir mit Ihnen ein einfaches, nützliches
      Programm zur Interaktion mit einem Yahoo! Wetter Web-Service erstellen.
      Während Sie in der Lage sein sollten, der Entwicklung dieses Kapitels
      ohne Beispiel-Quellcode zu folgen, empfehlen wir das Herunterladen einer
      Kopie der Quellcodes als Referenz. Das Beispielprojekt dieses Kapitel
      zusammen mit den anderen Beispielen dieses Buchs kann von
      http://books.sonatype.com/maven-book/mvn-examples-1.0.zip oder
      http://books.sonatype.com/maven-book/mvn-examples-1.0.tar.gz
      heruntergeladen werden. Entpacken Sie das Archiv in ein beliebiges
      Verzeichnis, und gehen Sie dann zum Unterverzeichnis <filename>/ch04</filename>. Darin befindet sich
      ein Verzeichnis mit dem Namen <filename>/simple weather</filename> welches den Quellcode für
      dieses Kapitel enthält.</para>
    </section>
  </section>

  <section id="customizing-sect-simple-weather">
    <title>Eine kurze Einführung in das "Simple Weather" Projekt </title>

    <para>Bevor wir loslegen, lassen Sie uns einen Schritt zurücktreten und das
    Wetter Projekt vorstellen. Was ist das, das 'Simple Weather' Projekt? Das
    einfache Wetterdienst-Projekt ist ein Beispiel, das speziell konstruiert wurde
    um einige der Funktionen von Maven vorzustellen. Es handelt sich um eine
    Anwendung, welche beispielhaft die Art der Anwendung vorstellt, welche Sie
    zu bauen angefragt werden. Die 'Simple Weather' Anwendung ist ein ein
    grundlegendes Beispiel einer befehlszeilenorientierten Anwendung, welche
    auf eine angegebene Postleitzahl Daten vom Yahoo! RSS WetterDienst abruft.
    Die Anwendung analysiert den Rückgabewert und gibt diesen auf der Konsole
    aus.</para>

    <para>Es gab eine Reihe von Gründen welche uns bewogen dieses Beispiel
    auszuwählen: zum einen ist es unkompliziert, der Benutzer macht eine Eingabe
    über die Befehlszeile; diese nehmen wir auf, schicken die Anfrage an
    den Yahoo! Wetter Dienst (RSS), analysieren das Ergebnis und geben zuletzt einige
    Daten auf den Bildschirm aus. Dieses Beispiel besteht aus einer einfachen
    <methodname>main()</methodname>-Klasse und einigen Hilfsklassen, es gibt kein Enterprise Framework
    einzuführen, lediglich einfaches XML-Parsen sowie einige
    Logging-Anweisungen. Zum anderen gibt dieses Beispiel uns eine gute
    Gelegenheit einige interessante Bibliotheken wie Velocity, Dom4J und Log4J
    einzuführen - Obwohl dieses Buch sich auf die Einführung von Maven
    konzentriert, werden wir uns nicht scheuen, die Gelegenheit zur Einführung
    interessanter Utilities wahrzunehmen. Schließlich ist es ein Beispiel, das
    in einem einzigen Kapitel eingeführt, entwickelt, und deployed werden
    kann.</para>

    <section id="customizing-sect-yahoo-weather">
      <title>Yahoo! Wetter Dienst RSS </title>

      <para>Bevor Sie diese Anwendung bauen, sollten Sie etwas mehr
      über die Yahoo! Wetter Dienste (RSS-Feeds) erfahren. Allem voraus weisen wir
      darauf hin, dass der Dienst unter den folgenden Konditionen angeboten
      wird:</para>

      <blockquote>
        <para>"Die Datendienste werden zur Nutzung von Einzelpersonen sowie
        Non-Profit-Organisationen kostenlos, im Rahmen von persönlichen, nicht
        kommerziellen Anwendungen angeboten. Sie sind angehalten auf die
        Nutzung der Yahoo! Wetter Dienste im Rahmen Ihres Angebotes
        hinzuweisen."</para>
      </blockquote>

      <para>Mit anderen Worten, wenn Sie daran dachten, diese Dienste in Ihren
      kommerziellen Webauftritt zu integrieren, dann gehen Sie bitte noch
      einmal über die Bücher: die Nutzung der Dienste ist lediglich für den
      privaten, nicht kommerziellen Gebrauch gestattet. Die Nutzung zu welcher
      wir in diesem Kapitel anregen ist beschränkt auf die persönliche
      Weiterbildung. Weitere Informationen bezüglich der Yahoo! Wetter Dienst
      Konditionen finden Sie in der Yahoo Wetter! API-Dokumentation:
      http://developer.yahoo.com/weather/.</para>
    </section>
  </section>

  <section id="customizing-sect-creating-simple-weather">
    <title>Erstellen des "Simple Weather" Projektes</title>

    <para>In einem ersten Schritt, lassen Sie uns mit Hilfe des Archetype
    Maven Plugin ein grundlegendes Skelett der Anwendung erstellen. Führen Sie
    den folgenden Aufruf aus, um ein neues Projekt zu generieren:</para>

    <screen><command>$ mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch04 \
                                         -DartifactId=simple-weather \
                                         -DpackageName=org.sonatype.mavenbook \
                                         -Dversion=1.0
</command>[INFO] [archetype:create]
[INFO] artifact org.apache.maven.archetypes:maven-archetype-quickstart: \
       checking for updates from central
[INFO] ------------------------------------------------------------------
[INFO] Using following parameters for creating Archetype: \
       maven-archetype-quickstart:RELEASE
[INFO] ------------------------------------------------------------------
[INFO] Parameter: groupId, Value: org.sonatype.mavenbook.ch04
[INFO] Parameter: packageName, Value: org.sonatype.mavenbook
[INFO] Parameter: basedir, Value: ~/examples
[INFO] Parameter: package, Value: org.sonatype.mavenbook
[INFO] Parameter: version, Value: 1.0
[INFO] Parameter: artifactId, Value: simple-weather
[INFO] *** End of debug info from resources from generated POM ***
[INFO] Archetype created in dir: ~/examples/simple-weather</screen>

    <para>Sobald das Archetype Maven Plugin das Projekt erstellt hat, wechseln
    Sie in das Verzeichnis der "Simple Weather" Anwendung und werfen Sie einen
    Blick auf die <filename>pom.xml</filename> Datei. Sie sollten das folgende XML-Dokument
    vorfinden:</para>

    <example id="ex-initial-pom-for-simple-weather">
      <title>Erstes POM des "Simple Weather" Projekts</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.ch04&lt;/groupId&gt;
  &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;name&gt;simple-weather2&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.5&lt;/source&gt;
          &lt;target&gt;1.5&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>Bitte beachten Sie, dass wir den Parameter <varname>version</varname> und das Goal
    <varname>archetype:create</varname> übergeben haben. Hiermit wird der Standardwert des
    1.0-SNAPSHOT überschrieben. In diesem Projekt entwickeln wir die Version
    1.0 des "Simple Weather" Beispielprogramms, wie Sie leicht am Element
    <varname>version</varname> der <filename>pom.xml</filename>-Datei ablesen können. </para>
  </section>

  <section id="customizing-sect-customizing-project-info">
    <title>Anpassen der Projektinformationen </title>

    <para>Bevor wir mit dem Schreiben von Quellcode loslegen, Lassen Sie uns die
    Projektinformationen ein wenig Anpassen. Wir wollen etliche Informationen
    bezüglich der Lizenzrechte, der Organisation sowie der beteiligten
    Entwickler einfügen. Dies alles sind Standard-Informationen welche wir
    erwarten, dass diese in den meisten Projekten gebraucht werden. Die
    folgende Auflistung zeigt den Ausschnitt der XML-Datei, der die
    Informationen zur Organisation, der Lizenzierung sowie bezüglich der
    Entwickler bereitstellt.</para>

    <example id="ex-custom-org-info">
      <title>Informationen bezüglich der Organisation, rechtlicher Belange
      sowie der Entwickler in der pom.xml-Datei</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
...

  &lt;name&gt;simple-weather&lt;/name&gt;
  &lt;url&gt;http://www.sonatype.com&lt;/url&gt;

  &lt;licenses&gt;
    &lt;license&gt;
      &lt;name&gt;Apache 2&lt;/name&gt;
      &lt;url&gt;http://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt;
      &lt;distribution&gt;repo&lt;/distribution&gt;
      &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;
    &lt;/license&gt;
  &lt;/licenses&gt;

  &lt;organization&gt;
    &lt;name&gt;Sonatype&lt;/name&gt;
    &lt;url&gt;http://www.sonatype.com&lt;/url&gt;
  &lt;/organization&gt;

  &lt;developers&gt;
    &lt;developer&gt;
      &lt;id&gt;jason&lt;/id&gt;
      &lt;name&gt;Jason Van Zyl&lt;/name&gt;
      &lt;email&gt;jason@maven.org&lt;/email&gt;
      &lt;url&gt;http://www.sonatype.com&lt;/url&gt;
      &lt;organization&gt;Sonatype&lt;/organization&gt;
      &lt;organizationUrl&gt;http://www.sonatype.com&lt;/organizationUrl&gt;
      &lt;roles&gt;
        &lt;role&gt;developer&lt;/role&gt;
      &lt;/roles&gt;
      &lt;timezone&gt;-6&lt;/timezone&gt;
    &lt;/developer&gt;
  &lt;/developers&gt;
...
&lt;/project&gt;
</programlisting>
    </example>

    <para>Die Auslassungspunkte ("...") in Beispiel 4.2, "Informationen
    bezüglich der Organisation, rechtlicher Belange sowie der Entwickler in
    der pom.xml-Datei" sind eine Abkürzung für ein stark gekürztes Listing.
    Wenn Sie in diesem Buch auf eine pom.xml Datei stossen, welche direkt
    hinter dem Element-Tag <varname>project</varname> mit "..." beginnt und mit "..." direkt vor
    dem Element <varname>project</varname> aufhört, so zeigt dies an, dass wir nicht die gesamte
    pom.xml-Datei wiedergeben. In diesem Fall wurden die Tag-Elemente <varname>licenses</varname>,
    <varname>organization</varname> und <varname>developers</varname> vor dem Element <varname>dependencies</varname>
    eingefügt.</para>
  </section>

  <section id="customizing-sect-add-depend">
    <title>Einfügen neuer Abhängigkeiten </title>

    <para>Die einfache "Simpel Weather" Anwendung umfasst folgende drei
    Aufgaben: Abrufen von XML-Daten vom Yahoo! Wetter Dienst, analysieren des zurückgegebenen
    XML von Yahoo und schliesslich die formatierte Ausgabe auf der Konsole. Um
    diese Aufgaben zu erledigen, müssen wir einige neue Abhängigkeiten zu
    unserem Projekt pom.xml hinzufügen. Um die XML-Antwort des Yahoo! Dienstes
    zu analysieren werden wir <term>Dom4J</term> und <term>Jaxen</term> einsetzen. Um die Ausgabe des
    Kommandozeilenprogramms zu formatieren setzen wir <term>Velocity</term> ein und es ist
    ebenfalls notwendig, eine Abhängigkeit zu <term>Log4J</term> hinzuzufügen, um
    Ereignisse zu loggen. Nachdem wir diese Abhängigkeiten einbringen, sieht
    unsere Beispiel pom.xml-Datei wie folgt aus:</para>

    <example>
      <title>Hinzufügen der Abhängigkeiten von Dom4J, Jaxen, Velocity und
      Log4J</title>

      <programlisting language="xml">&lt;project&gt;
  [...]
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.14&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;dom4j&lt;/groupId&gt;
      &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
      &lt;version&gt;1.6.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;jaxen&lt;/groupId&gt;
      &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
      &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;velocity&lt;/groupId&gt;
      &lt;artifactId&gt;velocity&lt;/artifactId&gt;
      &lt;version&gt;1.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  [...]
&lt;/project&gt;</programlisting>
    </example>

    <para>Wie Sie sehen, haben wir zum bestehenden Element der Test bezogenen
    Abhängigkeit JUnit, vier weitere Elemente dependency eingefügt. Nach dem
    Einfügen der Abhängigkeiten sowie dem Aufruf von <command>mvn install</command> werden Sie
    sehen, wie Maven diese Abhängigkeiten wie auch eine Reihe transitiver
    Abhängigkeiten in Ihr lokales Maven Repository herunterlädt.</para>

    <para>Nun wie wussten wir die Koordinaten dieser Abhängigkeiten? "Weiss"
    man schlicht die entsprechenden Werte für <varname>groupId</varname> und <varname>artifactId</varname>? Manche
    Artefakte sind so weit verbreitet (z.B. <classname>Log4J</classname>), dass Sie, wann immer Sie
    sie brauchen, sich an die Werte der <varname>groupId</varname> und <varname>artifactId</varname> erinnern werden.
    Velocity, Dom4J und Jaxen haben wir unter Einsatz einer hilfreichen
    Website (http://www.mvnrepository.com) aufgelöst. Diese Website bietet
    eine Maske zur Suche über das Maven-Repository an. Sie können die Site
    benutzen um Abhängigkeiten herauszufinden.</para>
    <para>Um dies zu verifizieren,
    versuchen Sie es selbst: laden Sie die Seite http://www.mvnrepository.com
    und suchen Sie nach einigen häufig verwendeten Bibliotheken wie Hibernate
    oder dem Spring Framework. Wenn Sie auf dieser Site nach einem Artefakt
    suchen, werden Ihnen der <varname>artefactId</varname>-Wert sowie alle im zentralen
    Repository verfügbaren <varname>version</varname>-Werte ausgegeben. Ein Klick auf die Details
    einer bestimmten Version lädt eine Seite, welche das Element dependency
    wiedergibt, dieses können Sie kopieren und in die pom.xml Datei Ihres eigenen Projekt einfügen.
    Wenn Sie eine Abhängigkeit finden müssen, so lohnt es
    sich, mvnrepository.com zu benutzen. Auch werden Sie dann werden festestellen, dass
    bestimmte Bibliotheken über mehr als eine <varname>groupId</varname> verfügen. Dieses
    Werkzeug wird Ihnen helfen das Maven-Repository zu verstehen. </para>
  </section>

  <section id="customizing-sect-simple-weather-source">
    <title>Quellcode von "Simple Weather" </title>

    <para>Das "Simple Weather" Beispielprogramm besteht aus fünf
    Java-Klassen:</para>

    <variablelist>
      <varlistentry>
        <term><classname>org.sonatype.mavenbook.weather.Main</classname></term>

        <listitem>
          <para>Diese Klasse enthält eine statische <methodname>main()</methodname>-Funktion, es ist der
          Ausgangspunkt für dieses System.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><classname>org.sonatype.mavenbook.weather.Weather</classname></term>

        <listitem>
          <para>Die Weather-Klasse ist ein einfaches Java-Bean, welches die
          Koordinaten unseres Wetterberichtes, sowie eine Anzahl wichtiger
          Daten wie z.B Temperatur und Luftfeuchtigkeit vorhält.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><classname>org.sonatype.mavenbook.weather.YahooRetriever</classname></term>

        <listitem>
          <para>Die YahooRetriever Klasse stellt eine Verbindung zum Yahoo! Wetter
          Dienst her und liefert einen InputStream der Daten des
          Dienstes.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><classname>org.sonatype.mavenbook.weather.YahooParser</classname></term>

        <listitem>
          <para>Die YahooParser Klasse analysiert das zurückgegebene XML vom Yahoo!
          Wetter Dienst und wandelt es in ein Weather-Objekt um.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><classname>org.sonatype.mavenbook.weather.WeatherFormatter</classname></term>

        <listitem>
          <para>Die WeatherFormatter Klasse setzt auf einem Weather Objekt auf,
          erstellt einen VelocityContext, und führt ein Velocity Template
          (Vorlage) daruaf aus.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Wir wollen an diese Stelle nicht näher auf den Quellcode des
    Beispiels eingehen, werden aber alle erforderlichen Quellen des Beispiels
    im Buch bereitstellen, so dass Sie "Simple Weather" zum Laufen bekommen.
    Wir gehen davon aus, dass die meisten von Ihnen den Quellcode
    heruntergeladen haben, wollen aber mit den Beispielen des Buches aber auch jene Leser
    berücksichtigen, welche den Beispielen innerhalb des Kapitels
    Schritt-für-Schritt folgen. Die folgenden Abschnitte legen den Quellcode
    der Klassen des "Simple Weather" Projekt dar. Diese Klassen sollten alle in
    das gleiche Paket <classname>com.sonatype.maven.weather</classname> abgelegt werden.</para>

    <para>Lassen Sie uns die App sowie die AppTest Klassen welche das Goal
    <varname>archetype:create</varname> erzeugt hat, entfernen und unsere neuen Klassen dem
    Package zufügen. In einem Maven-Projekt, liegen alle Quellen eines
    Projektes unter <filename>/src/main/java</filename>. Aus dem Basis-Verzeichnis des neuen
    Projekts heraus, führen Sie die folgenden Befehle aus:</para>

    <screen>$ <command>cd src/test/java/org/sonatype/mavenbook</command>
$ <command>rm AppTest.java</command>
$ <command>cd ../../../../../..</command>
$ <command>cd src/main/java/org/sonatype/mavenbook</command>
$ <command>rm App.java</command>
$ <command>mkdir weather</command>
$ <command>cd weather</command></screen>

    <para>Sie haben ein neues Paket <classname>com.sonatype.maven.weather</classname> erstellt. Nun
    sollten wir etliche Klassen in diesem Verzeichnis erstellen. Benutzen Sie hierfür Ihren
    Lieblings-Text-Editor und erstellen Sie eine neue Datei mit dem Namen
    Weather.java mit folgendem Inhalt:</para>

    <example id="ex-simple-weather-model-object">
      <title>"Simple Weather" Wetter Objekt Modell</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

public class Weather {
  private String city;
  private String region;
  private String country;
  private String condition;
  private String temp;
  private String chill;
  private String humidity;
    
  public Weather() {}

  public String getCity() { return city; }
  public void setCity(String city) { this.city = city; }

  public String getRegion() { return region; }
  public void setRegion(String region) { this.region = region; }

  public String getCountry() { return country; }
  public void setCountry(String country) { this.country = country; }

  public String getCondition() { return condition; }
  public void setCondition(String condition) { this.condition = condition; }

  public String getTemp() { return temp; }
  public void setTemp(String temp) { this.temp = temp; }
         
  public String getChill() { return chill; }
  public void setChill(String chill) { this.chill = chill; }

  public String getHumidity() { return humidity; }
  public void setHumidity(String humidity) { this.humidity = humidity; }
}
</programlisting>
    </example>

    <para>Die Wetter Klasse definiert ein einfaches Bean, welches die
    Informationen vorhält, welche aus den vom Yahoo! Wetter-Dienst zurückgegebenen Daten geparsed
    werden. Der Yahoo! Wetter-Dienst bietet eine Fülle an Informationen,
    ausgehend von den Sonnenaufgangs und -untergangszeiten, bis hin zur
    Windrichtung sowie -geschwindigkeit. Im Ansinnen, die Beispiele des Buchs
    so einfach wie möglich zu gestalten, enthält unser Weeather-Objekt-Modell
    nur die Temperatur, Chill, Feuchtigkeit und sowie eine textuelle
    Beschreibung der gegenwärtigen Bedingungen.</para>

    <para>Im gleichen Verzeichnis erstellen Sie nun eine Datei mit dem Namen
    <filename>Main.java</filename>. Diese Haupt-Klasse wird die statische main()-Funktion
    beinhalten, welche der Einstiegspunkt dieses Beispiels ist.</para>

    <example>
      <title>Einfache Weather-Hauptklasse </title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStream;

import org.apache.log4j.PropertyConfigurator;


public class Main {

  public static void main(String[] args) throws Exception {
    // Configure Log4J
    PropertyConfigurator.configure(Main.class.getClassLoader()
                                       .getResource("log4j.properties"));

    // Read the Zip Code from the Command-line (if none supplied, use 60202)
    String zipcode = "60202";
    try {
      zipcode = args[0]);
    } catch( Exception e ) {}

    // Start the program
    new Main(zipcode).start();
  }

  private String zip;

  public Main(String zip) {
    this.zip = zip;
  }

  public void start() throws Exception {
    // Retrieve Data
    InputStream dataIn = new YahooRetriever().retrieve( zip );

    // Parse Data
    Weather weather = new YahooParser().parse( dataIn );

    // Format (Print) Data
    System.out.print( new WeatherFormatter().format( weather ) );
  }
}
</programlisting>
    </example>

    <para>Die oben gezeigte <methodname>main()</methodname>-Funktion konfiguriert Log4J indem es eine
    Ressource (<filename>log4j.properties</filename>) auf dem Klassenpfad sucht, um anschliessend
    einen ZIP-Code/eine Postleitzahl von der Befehlszeile zu lesen. Wird eine
    während des Leseversuchs eine Exception geworfen, wird standardmässig auf die
    Postleitzahl 60202 zurückgegriffen. Sobald dem Programm eine Postleitzahl
    zugeführt wird, wird main() instanziert und deren start()-Methode aufgerufen. Die
    start()-Methode ruft die YahooRetriever Klasse auf, um das XML-Wetter abzurufen. Die Klasse 
    YahooRetriever liefert einen InputStream, welcher an die Klasse YahooParser
    weitergeleitet wird. YahooParser analysiert das zurückgegebene Yahoo! Wetter XML und
    erstellt ein Weather-Objekt. Schließlich nimmt der WeatherFormatter das
    Weather Objekt und spuckt eine formatierte Zeichenfolge aus, welche auf der
    Standardausgabe ausgegeben wird.</para>

    <para>Erstellen Sie nun im gleichen Verzeichnis eine Datei mit dem Namen
    YahooRetriever.java mit folgendem Inhalt:</para>

    <example id="ex-simple-weather-yahoo-retriever-class">
      <title>"Simple Weather" YahooRetriever Klasse </title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;

import org.apache.log4j.Logger;

public class YahooRetriever {

  private static Logger log = Logger.getLogger(YahooRetriever.class);

  public InputStream retrieve(int zipcode) throws Exception {
    log.info( "Retrieving Weather Data" );
    String url = "http://weather.yahooapis.com/forecastrss?p=" + zipcode;
    URLConnection conn = new URL(url).openConnection();
    return conn.getInputStream();
  }
}
</programlisting>
    </example>

    <para>Diese einfache Klasse öffnet eine URLConnection auf die Yahoo!
    Wetter-API und liefert einen InputStream. Um den InputStream verarbeiten
    zu können müssen wir im gleichen Verzeichnis eine Datei YahooParser.java
    erstellen.</para>

    <example>
      <title>"Simple Weather" YahooParser Klasse</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;
import org.dom4j.Document;
import org.dom4j.DocumentFactory;
import org.dom4j.io.SAXReader;

public class YahooParser {

  private static Logger log = Logger.getLogger(YahooParser.class);

  public Weather parse(InputStream inputStream) throws Exception {
    Weather weather = new Weather();
  
    log.info( "Creating XML Reader" );
    SAXReader xmlReader = createXmlReader();
    Document doc = xmlReader.read( inputStream );

    log.info( "Parsing XML Response" );
    weather.setCity( doc.valueOf("/rss/channel/y:location/@city") );
    weather.setRegion( doc.valueOf("/rss/channel/y:location/@region") );
    weather.setCountry( doc.valueOf("/rss/channel/y:location/@country") );
    weather.setCondition( doc.valueOf("/rss/channel/item/y:condition/@text") );
    weather.setTemp( doc.valueOf("/rss/channel/item/y:condition/@temp") );
    weather.setChill( doc.valueOf("/rss/channel/y:wind/@chill") );
    weather.setHumidity( doc.valueOf("/rss/channel/y:atmosphere/@humidity") );
  
    return weather;
  }

  private SAXReader createXmlReader() {
    Map&lt;String,String&gt; uris = new HashMap&lt;String,String&gt;();
        uris.put( "y", "http://xml.weather.yahoo.com/ns/rss/1.0" );
        
    DocumentFactory factory = new DocumentFactory();
    factory.setXPathNamespaceURIs( uris );
        
    SAXReader xmlReader = new SAXReader();
    xmlReader.setDocumentFactory( factory );
    return xmlReader;
  }
}
</programlisting>
    </example>

    <para>Der YahooParser ist die komplexeste Klasse in diesem Beispiel. Wir
    werden nicht in die Einzelheiten von Dom4J oder Jaxen eingehen, aber die
    Klasse benötigt dennoch ein wenig Erklärung. Die parse()-Methode von
    YahooParser nimmt einen InputStream auf und gibt ein Weather-Objekt
    zurück. Um dies zu tun, muss sie das XML-Dokument per DOM4J analysieren.
    Da wir an Elementen des Yahoo!Wetter Namespaces interessiert sind, ist es
    notwendig einen Namespace bewussten SAXReader in der
    Methode <methodname>createXmlReader()</methodname> zu erstellen. Sobald wir diesen Reader erstellt
    haben und damit das Dokument analysiert haben, bekommen wir ein
    <classname>org.dom4j.Document</classname>-Objekt zurück. Statt durch alle Kind-Elemente zu
    iterieren, adressieren wir die für uns relevanten Informationen direkt mit
    Hilfe eines XPath-Ausdrucks. Dom4J liefert in diesem Beispiel das
    XML-Parsing und Jaxen die XPath-Funktionalität.</para>

    <para>Haben wir einmal ein Weather-Objekt erzeugt, müssen wir unsere
    Ausgabe für den Gebrauch lesbar formatieren. Erstellen Sie im Verzeichnis
    der andern Klassen eine Datei mit dem Namen WeatherFormatter.java.</para>

    <example>
      <title>"Simple Weather" WeatherFormatter Klasse </title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;

import org.apache.log4j.Logger;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;

public class WeatherFormatter {

  private static Logger log = Logger.getLogger(WeatherFormatter.class);

  public String format( Weather weather ) throws Exception {
    log.info( "Formatting Weather Data" );
    Reader reader = 
      new InputStreamReader( getClass().getClassLoader()
                                 .getResourceAsStream("output.vm"));
    VelocityContext context = new VelocityContext();
    context.put("weather", weather );
    StringWriter writer = new StringWriter();
    Velocity.evaluate(context, writer, "", reader);
    return writer.toString();
  }
}
</programlisting>
    </example>

    <para>Die Klasse WeatherFormatter verwendet Velocity, um basierend auf
    einer Vorlage, die Ausgabe darzustellen. Die format()-Methode nimmt eine
    Weather Bean auf und gibt eine formatierte Zeichenkette zurück. Das erste,
    was die format()-Methode macht, ist eine Velocity Vorlage namens
    poutput.vm vom Klassenpfad zu laden. Wir erstellen dann einen
    VelocityContext welcher mit einem einzigen Weather Objekt namens <varname>weather</varname>
    bestückt wird. Ein <classname>StringWriter</classname> wird erstellt, um die Ergebnisse mit der
    Vorlage zu fusionieren. Die Vorlage wird mit einem Aufruf an
    Velocity.evaluate() ausgewertet und die Ergebnisse als String
    zurückgegeben.</para>

    <para>Bevor wir dieses Beispiel ausführen können, müssen wir noch einige
    Ressourcen auf unserem Klassenpfad erstellen.</para>
  </section>

  <section id="customizing-sect-add-resources">
    <title>Resourcen Hinzufügen</title>

    <para>Dieses Projekt hängt von zwei Klassenpfad Ressourcen ab: Die
    main()-Klasse konfiguriert Log4J mit <filename>log4j.properties</filename> vom Klassenpfad, und
    die WeatherFormatter Klasse greift auf eine Velocity Vorlage namens <filename>output.vm</filename>
    zurück. Beide Ressourcen müssen im Standard-Package (oder dem
    Wurzelverzeichnis des Klassenpfades) vorhanden sein.</para>

    <para>Um diese Ressourcen zuzufügen, müssen wir im Wurzelverzeichnis ein
    neues Verzeichnis <filename>/project-src/main/resources</filename> erstellen. Da das
    Verzeichnis nicht nicht vom Goal <varname>archetype:create</varname> geschaffen wurde, müssen
    wir dieses durch folgende Befehle aus dem Projekt Verzeichnis heraus erstellen:
    </para>

    <screen>$ <command>cd src/main</command>
$ <command>mkdir resources</command>
$ <command>cd resources</command></screen>

    <para>Sobald das Ressourcen-Verzeichnis erstellt ist, können wir die
    beiden Ressourcen zufügen. Zunächst fügen Sie die Datei <filename>log4j.properties</filename>
    in das Ressourcen-Verzeichnis ein.</para>

    <example id="ex-simple-weather-log4j-config">
      <title>"Simple Weather" Log4J Konfigurationsdatei </title>

      <programlisting language="java"># Set root category priority to INFO and its only appender to CONSOLE.
log4j.rootCategory=INFO, CONSOLE

# CONSOLE is set to be a ConsoleAppender using a PatternLayout.
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Threshold=INFO
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%-4r %-5p %c{1} %x - %m%n</programlisting>
    </example>

    <para>Diese Datei <filename>log4j.properties</filename> konfiguriert Log4J alle Log-Nachrichten
    mit einem PatternLayout an die Standard-Ausgabe zu senden. Schließlich
    brauchen wir eine Velocity Vorlage output.vm um die Ausgabe der
    Applikation darzustellen. Erstellen Sie output.vm im
    Ressourcen-Verzeichnis.</para>

    <example>
      <title>"Simple Weather" Output-Velocity-Template </title>

      <programlisting>*********************************
 Current Weather Conditions for:
  \${weather.city}, \${weather.region}, \${weather.country}
  
 Temperature: \${weather.temp}
   Condition: \${weather.condition}
    Humidity: \${weather.humidity}
  Wind Chill: \${weather.chill}
*********************************
</programlisting>
    </example>

    <para>Diese Vorlage enthält eine Reihe von Verweisen auf eine Variable
    namens <varname>weather</varname>. Die Variable <varname>weather</varname> ist das Weather Bean, welches an den
    WeatherFormatter gegeben wurde, die Syntax <varname>\${weather.temp}</varname> ist eine
    Kurzform um die Werte der Weather Bean aufzurufen und anzuzeigen. Nun, da
    wir allen Projekt-Code an den richtigen Stellen haben, können wir Maven
    benutzen, um dieses Beispiel aufzurufen.</para>
  </section>

  <section id="customizing-sect-custom-exec">
    <title>Ausführen des "Simple Weather" Programms</title>

    <para>Mit dem Exec Maven Plugin des Codehouse-Mojo-Projekts können wir das
    Programm ausführen. Um die main()-Klasse auszuführen, geben Sie den
    folgenden Befehl aus dem Projekt-Basis-Verzeichnis ein:</para>

    <screen>$ <command>mvn install</command>
/$ <command>mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main</command>
...
[INFO] [exec:java]
0    INFO  YahooRetriever  - Retrieving Weather Data
134  INFO  YahooParser  - Creating XML Reader
333  INFO  YahooParser  - Parsing XML Response
420  INFO  WeatherFormatter  - Formatting Weather Data
*********************************
 Current Weather Conditions for:
  Evanston, IL, US
  
 Temperature: 45
   Condition: Cloudy
    Humidity: 76
  Wind Chill: 38
*********************************
...</screen>

    <para>We didn’t supply a command-line argument to the
    <classname>Main</classname> class, so we ended up with the default zip
    code, 60202. To supply a zip code, we would use the
    <varname>-Dexec.args</varname> argument and pass in a zip code:</para>

    <screen>$ <command>mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main -Dexec.args="70112"</command>
...
[INFO] [exec:java]
0    INFO  YahooRetriever  - Retrieving Weather Data
134  INFO  YahooParser  - Creating XML Reader
333  INFO  YahooParser  - Parsing XML Response
420  INFO  WeatherFormatter  - Formatting Weather Data
*********************************
 Current Weather Conditions for:
  New Orleans, LA, US
  
 Temperature: 82
   Condition: Fair
    Humidity: 71
  Wind Chill: 82
*********************************
[INFO] Finished at: Sun Aug 31 09:33:34 CDT 2008
...</screen>

    <para>Da wir kein Kommandozeilen-Argument angegeben haben, wurde die
    Anwendung mit der Standard-Postleitzahl "60202" ausgeführt. Wie Sie sehen
    können, haben wir das "Simple Weather" Tool erfolgreich aufgerufen, Daten
    von Yahoo! Wetter abgerufen, das Ergebnis analysiert, formatiert und die
    sich daraus ergebenden Daten mit Hilfe von Velocity ausgegeben. Wir haben
    all dies erreicht, ohne dabei viel mehr zu tun als unseres Projekt's
    Source-Code erstellen, sowie minimale Konfiguration an der pom.xml
    vorzunehmen. Beachten Sie, dass kein "Build-Prozess" beteiligt war. Wir
    mussten nicht festlegen wie oder wo die Java-Compiler unseren Quellecode
    kompiliert, wir haben nichts zu tun, um das Build-System zu finden,
    anzugeben wie der Bytecode ausgeführt werden soll um die
    Beispiel-Anwendung auszuführen. Alles, was notwendig war, um etliche
    Abhängigkeiten einzufügen war, die entsprechenden Maven Koordinaten zu
    finden und in der pom.xml Datei einzutragen.</para>

    <section id="customizing-sect-maven-exec">
      <title>Das Exec Maven Plugin</title>

      <para>Der Exec-Plugin ermöglicht Ihnen die Ausführung von Java-Klassen
      und andere Skripten. Es ist keines der Kern- oder Core-Maven Plugins, aber
      es steht Ihnen vom Mojo Projekt gehostet von Codehaus zur Verfügung. Für
      eine vollständige Beschreibung der Exec-Plugins, führen Sie:</para>

      <screen>$ <command>mvn help:describe -Dplugin=exec -Dfull</command></screen>
		
      <para>aus</para>
      <para>Es wird alle Goals, welche das Exec Maven Plugin zur Verfügung
      stellt, auflisten. Das Help Plugin, wird auch alle gültigen Parameter des
      Exec-Plugins aufzeigen, sollten Sie dessen Verhalten anpassen wollen. Um
      dem Exec Plugin Kommandozeilenargumente mitzugeben, sehen Sie in der
      Dokumentation des Plugins nach, welche von <varname>help:describe</varname> wiedergegeben wird.
      Obschon das Exec-Plugin nützlich ist, solltens Sie es nicht ausserhalb
      der laufenden Tests während der Entwicklungsphase zur Ausführung von
      Anwendungen benutzen. Als robustere Lösung, verwenden Sie das Maven
      Plugin Assembly welches im Abschnitt 4.13: "Erstellen einer packetierten
      Kommandozeilen Anwendung" eingeführt wird. </para>
    </section>

    <section id="customizing-sect-exploring-dependencies">
      <title>Erkundung der Projekt Abhängigkeiten </title>

      <para>Das Exec-Plugin ermöglicht es uns, die Anwendung auszuführen, ohne
      die Abhängigkeiten explizit in den Klassenpfad aufzunehmen. In jedem
      anderen Build-System, wäre es notwendig geworden, alle Abhängigkeiten in
      eine Art <filename>/lib</filename>-Verzeichnis zu kopieren, welches eine Sammlung von
      JAR-Dateien enthält. Dann hätten wir ein einfaches Skript, welches den
      Bytecode des Programms sowie alle unsere Abhängigkeiten in den
      Klassenpfad einschliesst. Nur dann könnten wir <command>java
      com.sonatype.maven.weather.Main</command> ausführen. Das Exec Plugin nutzt die
      Tatsache, dass Maven bereits um die Erstellung und Verwaltung Ihres
      Klassenpfades und der Abhängigkeiten weiss.</para>

      <para>Während dies ist zwar bequem ist, ist es dennoch schön zu wissen,
      was genau in Ihren Klassenpfad eingeschlossen wird. Während des Projekt
      direkt nur von wenigen Bibliotheken wie Dom4J, Log4J, Jaxen, und
      Velocity abhängt, stützen diese sich auf weitere, transitive
      Abhängigkeiten. Um herauszufinden, wie Ihr Klassenpfad tatsächlich
      aussieht, können Sie das Dependency Maven Plugin zur Ausgabe einer Liste der
      aufgelösten Abhängigkeiten benutzen. Um die Liste der Abhängigkeiten des
      "Simple Weather" Projekts auszugeben, führen Sie das Goal <varname>dependency:resolve</varname>
      aus. </para>

      <screen>$ <command>mvn dependency:resolve</command>
...
[INFO] [dependency:resolve]
[INFO] 
[INFO] The following files have been resolved: 
[INFO]    com.ibm.icu:icu4j:jar:2.6.1 (scope = compile)
[INFO]    commons-collections:commons-collections:jar:3.1 (scope = compile)
[INFO]    commons-lang:commons-lang:jar:2.1 (scope = compile)
[INFO]    dom4j:dom4j:jar:1.6.1 (scope = compile)
[INFO]    jaxen:jaxen:jar:1.1.1 (scope = compile)
[INFO]    jdom:jdom:jar:1.0 (scope = compile)
[INFO]    junit:junit:jar:3.8.1 (scope = test)
[INFO]    log4j:log4j:jar:1.2.14 (scope = compile)
[INFO]    oro:oro:jar:2.0.8 (scope = compile)
[INFO]    velocity:velocity:jar:1.5 (scope = compile)
[INFO]    xalan:xalan:jar:2.6.0 (scope = compile)
[INFO]    xerces:xercesImpl:jar:2.6.2 (scope = compile)
[INFO]    xerces:xmlParserAPIs:jar:2.6.2 (scope = compile)
[INFO]    xml-apis:xml-apis:jar:1.0.b2 (scope = compile)
[INFO]    xom:xom:jar:1.0 (scope = compile)
</screen>

      <para>Wie Sie sehen, hat unser Projekt eine große Zahl von
      Abhängigkeiten. Auch wenn wir nur direkte Abhängigkeiten von vier
      Bibliotheken angegeben haben, scheinen insgesamt 15 Abhängigkeiten zu
      bestehen. Dom4J hängt von Xerces und dem XML-Parser-APIs ab, Jaxen hängt
      davon ab, dass Xalan sich im Klassenpfad befindet. Das Dependency Maven
      Plugin wird ihnen die endgültige Kombination von Abhängigkeiten unter
      welchen Ihr Projekt kompiliert wird ausgeben. Wollen Sie den gesamten
      Baum aller Abhängigkeiten sehen, so können Sie das Goal <varname>dependency:tree</varname>
      aufrufen: </para>

      <screen>$ <command>mvn dependency:tree</command>
...
[INFO] [dependency:tree]
[INFO] org.sonatype.mavenbook.ch04:simple-weather:jar:1.0
[INFO] +- log4j:log4j:jar:1.2.14:compile
[INFO] +- dom4j:dom4j:jar:1.6.1:compile
[INFO] |  \- xml-apis:xml-apis:jar:1.0.b2:compile
[INFO] +- jaxen:jaxen:jar:1.1.1:compile
[INFO] |  +- jdom:jdom:jar:1.0:compile
[INFO] |  +- xerces:xercesImpl:jar:2.6.2:compile
[INFO] |  \- xom:xom:jar:1.0:compile
[INFO] |     +- xerces:xmlParserAPIs:jar:2.6.2:compile
[INFO] |     +- xalan:xalan:jar:2.6.0:compile
[INFO] |     \- com.ibm.icu:icu4j:jar:2.6.1:compile
[INFO] +- velocity:velocity:jar:1.5:compile
[INFO] |  +- commons-collections:commons-collections:jar:3.1:compile
[INFO] |  +- commons-lang:commons-lang:jar:2.1:compile
[INFO] |  \- oro:oro:jar:2.0.8:compile
[INFO] +- org.apache.commons:commons-io:jar:1.3.2:test
[INFO] \- junit:junit:jar:3.8.1:test
...</screen>

      <para>Sollten Sie wirklich abenteuerlich sein, oder einfach nur die volle
      Liste der Abhängigkeiten sehen wollen, einschliesslich aller Artefakte,
      die aufgrund von Konflikten oder anderen Gründen abgelehnt wurden,
      führen Sie Maven mit dem Debug-Flag aus.</para>

      <screen>$ <command>mvn install -X</command>
...
[DEBUG] org.sonatype.mavenbook.ch04:simple-weather:jar:1.0 (selected for null)
[DEBUG]   log4j:log4j:jar:1.2.14:compile (selected for compile)
[DEBUG]   dom4j:dom4j:jar:1.6.1:compile (selected for compile)
[DEBUG]     xml-apis:xml-apis:jar:1.0.b2:compile (selected for compile)
[DEBUG]   jaxen:jaxen:jar:1.1.1:compile (selected for compile)
[DEBUG]     jaxen:jaxen:jar:1.1-beta-6:compile (removed - )
[DEBUG]     jaxen:jaxen:jar:1.0-FCS:compile (removed - )
[DEBUG]     jdom:jdom:jar:1.0:compile (selected for compile)
[DEBUG]     xml-apis:xml-apis:jar:1.3.02:compile (removed - nearer: 1.0.b2)
[DEBUG]     xerces:xercesImpl:jar:2.6.2:compile (selected for compile)
[DEBUG]     xom:xom:jar:1.0:compile (selected for compile)
[DEBUG]       xerces:xmlParserAPIs:jar:2.6.2:compile (selected for compile)
[DEBUG]       xalan:xalan:jar:2.6.0:compile (selected for compile)
[DEBUG]       xml-apis:xml-apis:1.0.b2.
[DEBUG]       com.ibm.icu:icu4j:jar:2.6.1:compile (selected for compile)
[DEBUG]   velocity:velocity:jar:1.5:compile (selected for compile)
[DEBUG]     commons-collections:commons-collections:jar:3.1:compile (selected for compile)
[DEBUG]     commons-lang:commons-lang:jar:2.1:compile (selected for compile)
[DEBUG]     oro:oro:jar:2.0.8:compile (selected for compile)
[DEBUG]   junit:junit:jar:3.8.1:test (selected for test)
</screen>

      <para>In der Debug-Ausgabe sehen wir die Eingeweide des
      Abhängigkeit-Management-Systems bei der Arbeit. Was Sie hier sehen, ist
      der vollständige Baum aller Abhängigkeiten für dieses Projekt. Maven listet die vollen
      Maven Koordinaten für alle Ihre Projekt-Abhängigkeiten und die
      Abhängigkeiten derer Abhängigkeiten (und die Abhängigkeiten der
      Abhängigkeiten der Abhängigkeiten). Sie können ersehen, dass "Simple
      Weather" von Jaxen abhängt, welches von xom abhängig ist was wiederum
      auf icu4j aufbaut. Aus dieser Ausgabe können Sie erkennen, dass Maven
      einen Graphen der Abhängigkeiten erstellt, hierbei Duplikate eliminiert
      und etwaige Versionskonflikte löst. Sollten Sie bezüglich Abhängigkeiten
      auf Probleme stossen, so ist es oft hilfreich ein wenig tiefer im
      Baum den Abhängigkeiten zu schürfen. Durch Einschalten der Debugausgabe
      können Sie den Maven Abhängigkeits-Mechanismus bei der Arbeit
      sehen.</para>
    </section>
  </section>

  <section id="customizing-sect-writing-tests">
    <title>Erstellen von Unit-Tests</title>

    <para>Maven hat eine eingebaute Unterstützung für Unit-Tests. Testen ist
    ein Teil des ursprünglichen Maven Lebenszyklus. Lassen Sie uns ein paar
    Unit-Tests zum "Simple Weather" Projekt hinzufügen. Zuerst werden wir ein
    Package <classname>com.sonatype.maven.weather</classname> unter <classname>/src/test/java</classname> erstellen.</para>

    <screen>$ <command>cd src/test/java</command>
$ <command>cd org/sonatype/mavenbook</command>
$ <command>mkdir -p weather/yahoo</command>
$ <command>cd weather/yahoo</command></screen>

    <para>An dieser Stelle werden wir zwei Unit-Tests erstellen. Der erste
    Unit Test wird die Klasse YahooParser, der zweite die WeatherFormatter
    Klasse testen. Erstellen Sie eine Datei mit dem Namen YahooParserTest.java
    mit folgendem Inhalt im Package weather: </para>

    <example>
      <title>"Simple Weather" YahooParserTest Unit-Test </title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.yahoo;

import java.io.InputStream;

import junit.framework.TestCase;

import org.sonatype.mavenbook.weather.Weather;
import org.sonatype.mavenbook.weather.YahooParser;

public class YahooParserTest extends TestCase {

  public YahooParserTest(String name) {
    super(name);
  }
 
  public void testParser() throws Exception {
    InputStream nyData = 
      getClass().getClassLoader().getResourceAsStream("ny-weather.xml");
    Weather weather = new YahooParser().parse( nyData );
    assertEquals( "New York", weather.getCity() );
    assertEquals( "NY", weather.getRegion() );
    assertEquals( "US", weather.getCountry() );
    assertEquals( "39", weather.getTemp() );
    assertEquals( "Fair", weather.getCondition() );
    assertEquals( "39", weather.getChill() );
    assertEquals( "67", weather.getHumidity() );
  }
}
</programlisting>
    </example>

    <para>Dieser YahooParserTest erweitert die von JUnit definierte Klasse
    TestCase. Es folgt das übliche Muster für einen JUnit-Test: ein
    Konstruktor, der ein einziges String Argument annimmt und den Konstruktor
    der Superklasse aufruft und eine Reihe von public Methoden welche im Namen
    mit "test" beginnen, welche als Unit-Tests aufgerufen werden. Wir
    definieren ein einfaches Testvorgehen: testParser, welches den YahooParser
    überprüft, indem es ein XML-Dokument mit bekannten Werten auswertet. Das
    Test XML-Dokument heisst ny-weather.xml und wird aus dem Klassenpfad
    geladen. Wir fügen Test Ressourcen in Abschnitt 4.11: "Hinzufügen von Unit
    Test Ressourcen" an. In unserem Verzeichnisaufbau des Maven-Projekts
    befindet sich die Datei ny-weather.xml im Verzeichnis der Test-Ressourcen
    <filename>-- \${basedir}/src/test/resources</filename> unter
    <filename>/com/sonatype/maven/wetter/yahoo/ny-weather.xml</filename> . Die Datei wird als
    InputStream eingelesen und an die parse()-Methode des YahooParser
    geleitet. Die parse()-Methode liefert ein Weather Objekt zurück,welches
    über eine Anzahl von assertEquals() Aufrufen, eine innerhalb der Klasse TestCase definierte
    Methode, geprüft wird.</para>

    <para>Im gleichen Verzeichnis erstellen Sie eine Datei mit dem Namen
    WeatherFormatterTest.java.</para>

    <example>
      <title>"Simple Weather" WeatherFormatterTest Unit-Test </title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.yahoo;

import java.io.InputStream;

import org.apache.commons.io.IOUtils;

import org.sonatype.mavenbook.weather.Weather;
import org.sonatype.mavenbook.weather.WeatherFormatter;
import org.sonatype.mavenbook.weather.YahooParser;

import junit.framework.TestCase;

public class WeatherFormatterTest extends TestCase {

  public WeatherFormatterTest(String name) {
    super(name);
  }

  public void testFormat() throws Exception {
    InputStream nyData = 
      getClass().getClassLoader().getResourceAsStream("ny-weather.xml");
    Weather weather = new YahooParser().parse( nyData );
    String formattedResult = new WeatherFormatter().format( weather );
    InputStream expected = 
      getClass().getClassLoader().getResourceAsStream("format-expected.dat");
    assertEquals( IOUtils.toString( expected ).trim(), 
                  formattedResult.trim() );
  }
}
</programlisting>
    </example>

    <para>Der zweite Unit Test dieses einfachen Projekts testet die
    Klasse WeatherFormatter. Wie bereits die Klasse YahooParserTest, erweitert
    auch die Klasse WeatherFormatterTest die Klasse TestCase des JUnit Frameworks. Die
    einzige Testfunktion liest die gleiche Testressource von
    <filename>\${basedir}/src/test/resources</filename> umter dem
    <filename>/com/sonatype/Maven/Wetter/yahoo</filename>-Verzeichnis unter Einbezug des Unit Test
    Klassenpfades. Wir fügen Test Ressourcen wie im Abschnitt 4.11:
    "Hinzufügen Unit Test Ressourcen" beschrieben an. WeatherFormatterTest
    zieht diese Beispiel-Eingabedatei durch den YahooParser an, welcher ein
    Weather Objekt zurückgibt an, dieses Objekt wird dann mit dem
    WeatherFormatter ausgegeben. Da WeatherFormatter eine Zeichenkette
    ausgibt, müssen wir gegen eine gesetzte Eingabe testen. Unser
    "gesetzter" Input wurde einer Text-Datei mit dem Namen
    <filename>format-expected.dat</filename> erfasst, welche sich im gleichen Verzeichnis wie
    ny-weather.xml befindet. Um die Test-Ausgabe mit der erwarteten Ausgabe zu
    vergleichen, wird diese als InputStream eingelesen und unter Einbezug der
    Klasse IOUtils aus Apache Commons IO in einen String umgewandelt. Diese
    Zeichenfolge wird dann mittels assertEquals() mit der Testausgabe verglichen.
    </para>
  </section>

  <section id="customizing-sect-test-scope">
    <title>Hinzufügen von Gebietsbezogenen Unit Tests</title>

    <para>In der Klasse WeatherFormatterTest benutzten wir ein Dienstprogramm
    aus Apache Commons IO- die Klasse IOUtils. IOUtils bietet eine Reihe von
    hilfreichen statische Funktionen, welche den Grossteil der Arbeit der
    Input/Output-Operationen übernehmen. In diesem speziellen Unit Test
    benutzen wir IOUtils.toString() um die <filename>format-expected.dat</filename>
    Klassenpfadressource in einen String zu verwandeln. Wir hätten dies auch
    ohne den Einsatz von Commons IO bewerkstelligen können, aber es hätte
    zusätzliche sechs oder sieben Zeilen Code bedingt um mit den verschiedenen
    InputStreamReader- und StringWriter-Objekten umzugehen. Der Hauptgrund für
    den Einsatz der Commons IO Bibliothek war, uns eine Ausrede zu geben,
    Test-scoped (abgegrenzte) Abhängigkeiten am Beispiel von Commons IO einzuführen.</para>

    <para>Eine Test-scoped Abhängigkeit ist eine Abhängigkeit, welche nur auf
    während der Testkompilierung und Testausführung auf dem Klassenpfad eingeschlossen ist.
    Sollte Ihr Projekt als war- oder ear-Archiv packetiert werden, so würde eine
    Test-scoped Abhängigkeit nicht in das Projekt-Output-Archiv einbezogen werden.
    Um eine Test-scoped Abhängigkeit zu erstellen, fügen Sie das folgende
    dependency-Element in Ihrem Projekt in das Element dependencies ein .</para>

    <example>
      <title>Das Hinzufügen einer Test-scoped Abhängigkeit </title>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;dependencies&gt;
    ...
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
      &lt;version&gt;1.3.2&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    ...
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
    </example>

    <para>Nachdem Sie diese Abhängigkeit der pom.xml Datei zugefügt haben, führen
    Sie <command>mvn dependency:resolve</command> aus: Sie sollten sehen, dass commons-io nun als
    eine Abhängigkeit mit Gebietsbezug test aufgeführt wird. Noch eine
    Kleinigkeit wird benötigt, bevor wir bereit sind diese Projekt Unit-Tests
    auszuführen. Wir müssen die Klassenpfad Ressourcen erstellen, von welchen diese
    Unit-Tests abhängen. Geltungsbereiche werden ausführlich im
    Abschnitt 9.4.1: "Geltungsbereiche von Abhängigkeiten" dargestellt.</para>
  </section>

  <section id="customizing-sect-custom-test-resource">
    <title>Hinzufügen einer Unit-Test Ressource</title>

    <para>Ein Unit Test hat Zugriff auf eine Reihe von testspezifischen
    Ressourcen. Häufig werden Sie Dateien mit den erwarteten Ergebnissen und
    Dummy-Dateien mit Eingabetexten auf dem Testklassenpfad ablegen. In diesem
    Projekt legen wir ein Test XML-Dokument für den YahooParserTest namens
    <filename>ny-weather.xml</filename> sowie eine Datei mit der erwarteten Ausgabe des
    WeatherFormatter unter <filename>format-expected.dat</filename> ab.</para>

    <para>Um Test Ressourcen einzufügen, müssen Sie zunächst das Verzeichnis
    <filename>/src/test/resources</filename> erstellen. Dies ist das Standard-Verzeichnis, in
    welchem Maven nach Unit-Test Ressourcen sucht. Erstellen Sie dieses
    Verzeichnis indem Sie die folgenden Befehle aus Ihrem
    Projekt-Basis-Verzeichnis heraus ausführen.</para>

    <screen>$ <command>cd src/test</command>
$ <command>mkdir resources</command>
$ <command>cd resources</command></screen>

    <para>Sobald Sie das Ressourcen-Verzeichnis erstellt haben, erstellen Sie
    eine Datei mit dem Namen <filename>format-expected.dat</filename> in diesem Verzeichnis.</para>

    <example>
      <title>"Simple Weather" WeatherFormatterTest erwartete Ausgabe</title>

      <programlisting>*********************************
 Current Weather Conditions for:
  New York, NY, US
  
 Temperature: 39
   Condition: Fair
    Humidity: 67
  Wind Chill: 39
*********************************
</programlisting>
    </example>

    <para>Diese Datei sollte vertraut aussehen. Es ist die gleiche Ausgabe,
    welche generiert wurde, als Sie das "Simple Weather" Projekt mit dem Exec
    Maven Exec starteten. Die zweite Datei welche Sie benötigen werden und
    daher im Ressourcen-Verzeichnis erstellen sollten ist
    <filename>ny-weather.xml</filename>.</para>

    <example>
      <title>"Simple Weather" YahooParserTest XML-Eingabe</title>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes" ?&gt;
&lt;rss version="2.0" xmlns:yweather="http://xml.weather.yahoo.com/ns/rss/1.0" 
     xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"&gt;
 &lt;channel&gt;
 &lt;title&gt;Yahoo! Weather - New York, NY&lt;/title&gt;
 &lt;link&gt;http://us.rd.yahoo.com/dailynews/rss/weather/New_York__NY/&lt;/link&gt;
 &lt;description&gt;Yahoo! Weather for New York, NY&lt;/description&gt;
 &lt;language&gt;en-us&lt;/language&gt;
 &lt;lastBuildDate&gt;Sat, 10 Nov 2007 8:51 pm EDT&lt;/lastBuildDate&gt;

 &lt;ttl&gt;60&lt;/ttl&gt;
 &lt;yweather:location city="New York" region="NY" country="US" /&gt;
 &lt;yweather:units temperature="F" distance="mi" pressure="in" speed="mph" /&gt;
 &lt;yweather:wind chill="39" direction="0" speed="0" /&gt;
 &lt;yweather:atmosphere humidity="67" visibility="1609" pressure="30.18" 
                      rising="1" /&gt;
  &lt;yweather:astronomy sunrise="6:36 am" sunset="4:43 pm" /&gt;
  &lt;image&gt;
 &lt;title&gt;Yahoo! Weather&lt;/title&gt;

 &lt;width&gt;142&lt;/width&gt;
 &lt;height&gt;18&lt;/height&gt;
 &lt;link&gt;http://weather.yahoo.com/&lt;/link&gt;
 &lt;url&gt;http://l.yimg.com/us.yimg.com/i/us/nws/th/main_142b.gif&lt;/url&gt;
 &lt;/image&gt;
 &lt;item&gt;
 &lt;title&gt;Conditions for New York, NY at 8:51 pm EDT&lt;/title&gt;

  &lt;geo:lat&gt;40.67&lt;/geo:lat&gt;
 &lt;geo:long&gt;-73.94&lt;/geo:long&gt;
  &lt;link&gt;http://us.rd.yahoo.com/dailynews/rss/weather/New_York__NY/\&lt;/link&gt;
 &lt;pubDate&gt;Sat, 10 Nov 2007 8:51 pm EDT&lt;/pubDate&gt;
 &lt;yweather:condition text="Fair" code="33" temp="39" 
                     date="Sat, 10 Nov 2007 8:51 pm EDT" /&gt;
 &lt;description&gt;&lt;![CDATA[
&lt;img src="http://l.yimg.com/us.yimg.com/i/us/we/52/33.gif" /&gt;&lt;br /&gt;
 &lt;b&gt;Current Conditions:&lt;/b&gt;&lt;br /&gt;
 Fair, 39 F&lt;BR /&gt;&lt;BR /&gt;
 &lt;b&gt;Forecast:&lt;/b&gt;&lt;BR /&gt;
  Sat - Partly Cloudy. High: 45 Low: 32&lt;br /&gt;
  Sun - Sunny. High: 50 Low: 38&lt;br /&gt;
 &lt;br /&gt;
 ]]&gt;&lt;/description&gt;
 &lt;yweather:forecast day="Sat" date="10 Nov 2007" low="32" high="45" 
                    text="Partly Cloudy" code="29" /&gt;

&lt;yweather:forecast day="Sun" date="11 Nov 2007" low="38" high="50" 
                   text="Sunny" code="32" /&gt;
  &lt;guid isPermaLink="false"&gt;10002_2007_11_10_20_51_EDT&lt;/guid&gt;
 &lt;/item&gt;
&lt;/channel&gt;
&lt;/rss&gt;</programlisting>
    </example>

    <para>Diese Datei enthält ein Test XML-Dokument für den YahooParserTest.
    Wir speichern diese Datei, um den YahooParser zu testen ohne
    eine XML-Antwort vom Yahoo! Wetterdienst abzurufen.</para>
  </section>

  <section id="customizing-sect-executing-tests">
    <title>Ausführen von Unit-Tests </title>

    <para>Nun, da die Unit Tests zu Ihrem Projekt bestehen, führen wir diese aus!
    Sie brauchen nichts weiter zu tun um die Unit Tests anzustossen: die
    Testphase ist ein normaler Bestandteil des Maven Lifecycles. Die Maven Tests werden
    automatisch ausgeführt sobald Sie <command>mvn package</command> oder <command>mvn install</command> aufrufen. Wenn
    Sie möchten, dass alle Phasen des Lebenszyklus bis einschließlich der
    Testphase ausgeführt werden, rufen Sie <command>mvn test</command> auf.</para>

    <screen>$ <command>mvn test</command>
...
[INFO] [surefire:test]
[INFO] Surefire report directory: ~/examples/simple-weather/target/\
                                  surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running org.sonatype.mavenbook.weather.yahoo.WeatherFormatterTest
0    INFO  YahooParser  - Creating XML Reader
177  INFO  YahooParser  - Parsing XML Response
239  INFO  WeatherFormatter  - Formatting Weather Data
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.547 sec
Running org.sonatype.mavenbook.weather.yahoo.YahooParserTest
475  INFO  YahooParser  - Creating XML Reader
483  INFO  YahooParser  - Parsing XML Response
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.018 sec

Results :

Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
</screen>

    <para>Der Aufruf von <command>mvn test</command> von der Befehlszeile veranlasst Maven zur
    Ausführung aller Phasen des Lebenszyklus' bis und mit der Testphase. Das
    Surefire Maven Plugin hat ein Goal test, welches an die Testphase gebunden
    ist. Dieses Goal test führt alle Unit-Tests des Projektes aus, welche sich
    unter <filename>/src/test/java</filename> befinden und einen Dateinamen von <filename>**/Test*.java</filename>,
    <filename>**/*Test.java</filename> sowie <filename>**/*TestCase.java</filename> haben. Für unser Projekt können Sie
    sehen, dass das Surefire Plugin mit dem Goal test die Unittests
    WeatherFormatterTest und YahooParserTest ausgeführt hat. Bei der
    Ausführung des Surefire Maven Plugins werden nicht nur die Tests
    ausgeführt, es werden auch XML- und Text-Berichte erzeugt und unter dem
    Verzeichnis <filename>\${basedir}/target/surefire-reports</filename> abgelegt. Sollten Ihre
    Tests fehlschlagen, so können Sie in diesem Verzeichnis von den Unit Tests
    angelegte Detailsangaben wie Fehlermeldungen oder Stack Traces der Unit
    Tests finden.</para>

    <section id="customizing-sect-ignoring-failures">
      <title>Ignorieren fehlgeschlagener Unit Tests</title>

      <para>Oft werden Sie an einem System arbeiten dessen Unit Tests
      scheitern. Sollten Sie Test-Driven Development (TDD) praktizieren, so
      ist die Anzahl der gescheiterten Tests ein Mass dafür, wie nahe der
      Vollendung Ihr Projekt ist. Sollten Sie trotz gescheiterter
      Unit-Tests dennoch gerne ein Produkt erstellen, so müssen Sie Maven
      anweisen, diese Unit Tests zu ignorieren. Das Standardverhalten von
      Maven ist es, nach einem gescheiterten Test den Build abzubrechen. Um
      den Build auch bei auftreten gescheiterter Tests weiterzuführen, müssen
      sie den Konfigurationseintrag <varname>testFailureIgnore</varname> des Surefire Maven
      Plugins auf "true" setzen. </para>

      <example>
        <title>Ignorieren von gescheiterten Unit-Test Fällen</title>

        <programlisting language="xml">&lt;project&gt;
  [...]
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  [...]
&lt;/project&gt;</programlisting>
      </example>

      <para>Die Plugin Dokumentation
      (http://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html)
      zeigt, dass dieser Parameter einen Ausdruck erklärt: </para>

      <example>
        <title>Plugin-Parameter-Ausdrücke </title>

        <programlisting>
       testFailureIgnore  Set this to true to ignore a failure during \
                          testing. Its use is NOT RECOMMENDED, but quite \
                          convenient on occasion.

    * Type: boolean
    * Required: No
    * Expression: \${maven.test.failure.ignore}

        // testFailureIgnore Setzen Sie diesen Parameter auf "true" um scheiternde Testfälle zu ignorieren. 
        // Die Benutzung des Parameters wird NICHT EMPFOHLEN, kann aber zu Zeiten recht nützlich sein!
       </programlisting>
      </example>

      <para>Dieser Ausdruck kann von der Befehlszeile mit dem 'D-Parameter'
      gesetzt werden:</para>

      <screen>$ <command>mvn test -Dmaven.test.failure.ignore=true</command></screen>
    </section>

    <section id="customizing-sect-skipping-tests">
      <title>Überspringen von Unit-Tests</title>

      <para>Sie können Maven auch so konfigurieren dass bestimmte Unit Tests
      ganz übersprungen werden. Vielleicht arbeiten Sie an einem sehr großen
      System, in welchem die Unit-Tests Minuten in Anspruch nehmen und Sie
      wollen nicht warten bis alle Unit-Tests abgeschlossen sind, um ein
      Produkt zu erstellen. Möglicherweise müssen Sie mit einem Legacy-System
      arbeiten, welches eine Reihe von scheiternden Unit-Tests umfasst. Anstelle
      der Behebung der Unit-Test Fehlern möchten Sie lediglich ein JAR-Archive
      erstellen. Maven sieht für diese Fälle vor, und stellt die Fähigkeit mit
      dem Parameter <varname>skip</varname> des Surefire Plugins zum überspringen von Unit-Tests
      bereit. Um beim Aufruf von der Befehlszeile die Unit Tests zu
      überspringen, fügen Sie einfach den Parameter <varname>maven.test.skip</varname> Ihrem
      angestrebten Goal an:</para>

      <screen>$ mvn install -Dmaven.test.skip=true
...
[INFO] [compiler:testCompile]
[INFO] Not compiling test sources
[INFO] [surefire:test]
[INFO] Tests are skipped.
...</screen>

      <para>Wenn das Surefire Plugin das Goal test erreicht, überspringt es
      die Unit-Tests, sollte der Parameter <varname>maven.test.skip</varname> auf "true" gesetzt
      sein. Eine weitere Art Maven zu konfigurieren Unit Tests zu
      überspringen ist, diese Konfiguration in Ihrer Projekt pom.xml-Datei
      vorzunehmen. Um dies zu tun, würde man ein Element plugin Ihrer Build
      Konfiguration zufügen.</para>

      <example>
        <title>Überspringen von Unit-Tests </title>

        <programlisting language="xml">&lt;project&gt;
  [...]
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;skip&gt;true&lt;/skip&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  [...]
&lt;/project&gt;</programlisting>
      </example>
    </section>
  </section>

  <section id="customizing-sect-custom-packaged">
    <title>Builden einer paketierten, Befehlszeilen orientierten
    Anwendung</title>

    <para>In Abschnitt 4.8, "Ausführen des "Simple Weather" Programms", haben
    wir die "Simple Weather" Anwendung unter Verwendung des Exec Maven Plugins
    ausgeführt. Auch wenn das Exec Plugin die Anwedung ausgeführt und und
    Ausgaben erzeugt hat, sollte man Maven nicht als Container zur Ausführung
    Ihrer Anwendungen ansehen. Sollten Sie Ihre Anwendung an andere
    weitergeben wollen, so werden sie dies sicher als JAR-Archive, oder als
    Archiv in ZIP oder GZIP Format tun wollen. Das folgende Vorgehen gibt
    einen Überblick über den Prozess mit Hilfe einer vordefinierter Assembly
    Definitionsdatei sowie dem Assembly Maven Plugin ein verteilbares JAR
    Archive zu erstellen, welches den Anwendungs-(Byte) Code sowie alle
    notwendigen Abhängigkeiten enthält.</para>

    <para>Das Assembly Maven Plugin ist ein Plugin welches Sie zur
    Zusammenstellung beliebiger Pakete zur Verteilung Ihrer Anwendung benutzen können.
    Sie können das Assembly Plugin dazu einsetzen, das Resultat in beliebiger
    Form zusammenzustellen, indem Sie eine darauf zugeschnittene Assembly
    Definitionsdatei erstellen. In einem späteren Kapitel werden wir Ihnen
    zeigen wie man eine zugeschnittene Assembly Definitionsdatei erstellt, um
    die "Simple Weather" in einem komplexeren Archiv zu deployen. In diesem
    Kapitel werden wir das vordefinierte Format <varname>jar-with-dependencies</varname>
    einsetzen. Um das Assembly Maven Plugin einzusetzen, müssen wir die
    folgende Anpassung an der bestehenden Konfiguration in der pom.xml-Datei
    vornehmen:</para>

    <example>
      <title>Konfigurieren der Assembly Maven Definition </title>

      <programlisting language="xml">&lt;project&gt;
  [...]
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
          &lt;/descriptorRefs&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  [...]
&lt;/project&gt;</programlisting>
    </example>

    <para>Sobald Sie die Konfigurationsänderung hinzugefügt haben, starten Sie
    den Build mit dem Aufruf <command>mvn assembly:assembly</command>. </para>

    <screen>$ <command>mvn install assembly:assembly</command>
...
[INFO] [jar:jar]
[INFO] Building jar: ~/examples/simple-weather/target/simple-weather-1.0.jar
[INFO] [assembly:assembly]
[INFO] Processing DependencySet (output=)
[INFO] Expanding: \
       .m2/repository/dom4j/dom4j/1.6.1/dom4j-1.6.1.jar into \
       /tmp/archived-file-set.1437961776.tmp
[INFO] Expanding: .m2/repository/commons-lang/commons-lang/2.1/\
                     commons-lang-2.1.jar
       into /tmp/archived-file-set.305257225.tmp
... (Maven Expands all dependencies into a temporary directory) ...
[INFO] Building jar: \
       ~/examples/simple-weather/target/\
         simple-weather-1.0-jar-with-dependencies.jar
</screen>

    <para>Nach dem Abarbeiten befindet sich unser Ergebnis im Verzeichnis
    <filename>/target</filename> in der Datei <filename>simple-weather-1.0-jar-with-dependencies.jar</filename>. Wieder
    können wir die <methodname>main()</methodname>-Klasse ausführen. Um die "Simple Weather"
    aufzurufen, geben sie folgenden Befehl auf der Kommandozeile
    im Projekt-Basis-Verzeichnis ein:</para>

    <screen>$ <command>cd target</command>
$ <command>java -cp simple-weather-1.0-jar-with-dependencies.jar \
                    org.sonatype.mavenbook.weather.Main 10002</command>
0    INFO  YahooRetriever  - Retrieving Weather Data
221  INFO  YahooParser  - Creating XML Reader
399  INFO  YahooParser  - Parsing XML Response
474  INFO  WeatherFormatter  - Formatting Weather Data
*********************************
 Current Weather Conditions for:
  New York, NY, US
  
 Temperature: 44
   Condition: Fair
    Humidity: 40
  Wind Chill: 40
*********************************</screen>

    <para>Das Format 'jar-with-dependencies' erstellt ein einziges JAR-Archiv,
    welches allen Bytecode der "Simple Weather" Anwendung sowie den entpackten
    Bytecode aller Abhängigkeiten enthält. Dieses etwas unkonventionelle
    Format eines Archivs kommt in einer 9 MiB Datei mit rund 5290 Klassen
    daher, aber dies ist ein einfaches Format, um Anwendungen welche Sie mit
    Maven entwickelt haben zu verteilen. Später in diesem Buch, werden wir
    Ihnen zeigen, wie Sie eine benutzerdefinierte Assembly Definitionsdatei
    erstellen um eine gewöhnliche Standard-Distribution zu erstellen.</para>

    <section id="customizing-sect-attaching-assembly">
      <title>Anbinden des Assembly Goals zur Packetierungs Phase</title>

      <para>Unter Maven 1 wurde ein Build massgeschneidert indem man eine
      Anzahl von Plugin Goals direkt aneinanderknüpfte. Jedes Plugin Goal
      hatte Vorbedingungen und definierte einen Bezug zu anderen Plugin Goals.
      Mit der Ankunft von Maven 2 wurde das Lebenszykluskonzept eingeführt,
      und Plugin Goals sind nun zu einer Anzahl Phasen zugeordnet, welche in
      einem Standard Lebenszyklus bestehen. Das Lebenszykluskonzept ist eine
      solide Grundlage, welche es vereinfacht, die Abfolge der Plugin Goals zu
      bestimmen und zu koordinieren welche Goals in einem bestimmten Build
      ausgeführt werden. Unter Maven 1 war der Bezug zwischen den Goals
      direkt, unter Maven 2 besteht der Bezug von Plugin Goals immer zu einer
      Menge von gemeinsamen Lebenszyklus Phasen. Obschon es zulässig ist, ein
      Goal direkt - wie beschrieben - von der Kommandozeile auszuführen, steht
      es eher im Einklang mit der Architektur von Maven 2, das Assembly mit
      dem Aufruf des Goals assembly:assembly während einer Phase des Maven
      Lebenszykluses aufzurufen. </para>

      <para>Die folgenden Plugin-Konfiguration konfiguriert das Maven Plugin
      Assembly, um das angefügte Goal während der Phase package des Maven
      Standard Lebenszykluses auszuführen. Das angefügte Goal führt das
      gleiche aus, wie schon das Goal assembly. Um das Goal assembly:attached
      der Phase package zuzuordnen benutzen wir das Element executions
      innerhalb des Elements plugin der Sektion build des Projekt POMs.</para>

      <example>
        <title>Anbinden des Assembly Goals zur Packetierungs Phase</title>

        <para><programlisting language="xml">&lt;project&gt;
  [...]
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
          &lt;/descriptorRefs&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;simple-command&lt;/id&gt;
          &lt;phase&gt;package&lt;/phase&gt;
          &lt;goals&gt;
            &lt;goal&gt;attached&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  [...]
&lt;/project&gt;</programlisting></para>
      </example>

      <para>Sobald Sie diese Änderung Ihres POMs angefügt haben müssen Sie nur
      noch <command>mvn package</command> aufrufen, um Ihr Assembly zu generieren. Die
      Konfiguration der execution wird sicherstellen, dass das Goal
      assembly:attached ausgeführt wird, sobald Maven in die Lebenszyklusphase
      package eintritt. </para>
    </section>
  </section>
</chapter>
