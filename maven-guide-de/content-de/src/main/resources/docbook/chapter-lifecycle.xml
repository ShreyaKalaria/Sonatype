<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="lifecycle">
  <title>Der Build Lebenszyklus</title>

  <section id="lifecycle-sect-structure">
    <title>Einführung</title>

    <para>Maven modelliert Projekte als <emphasis>Nomen</emphasis> welche von
    einem Projekt Objekt Modell (<acronym>POM</acronym>) beschrieben werden.
    Das <acronym>POM</acronym> fängt die Identität des Projektes ein: Was
    beinhaltet das Projekt? Welche Art der Packetierung benötigt das Projekt?
    Ist das Projekt ein abgeleitetes Projekt? Was sind die Abhängigkeiten? Im
    vorangegangenen Kapitel haben wir eingeführt wie ein Projekt beschrieben
    werden kann, was wir nicht eingeführt haben sind die Mechanismen mittels
    welchen Maven auf diesen Objekten agieren kann. Im Maven Universum werden
    <emphasis>Verben</emphasis> durch <literal>Goals</literal>, welche in
    Maven Plugins verpackt und an Lebenszyklusphasen gebunden sind,
    dargestellt. Ein Maven Lebenszyklus besteht aus einer Reihe namentlich
    benannter Lebenszyklusphasen: <varname>prepare-resources</varname>,
    <varname>compile</varname>, <varname>package</varname> und
    <varname>install</varname> neben anderen. Es gibt also eine Phase welche
    die Kompilierung beschreibt und eine Phase welche die Packetierung
    umfasst. Darüber hinaus gibt es vorbereitende und nachbereitende Phasen,
    welche benutzt werden, um Goals welche vor oder gerade nach einer
    bestimmten Phase abgearbeitet werden müssen zu registrieren. Sobald Sie
    Maven aufrufen um einen Build zu erstellen, rufen Sie tatsächlich Maven
    dazu auf eine bestimmte Kette von Phasen zu durchlaufen und alle an eine
    Phase gebndene Goals abzuarbeiten. </para>

    <para>Ein Build Lebenszyklus ist eine Abfolge von Phasen welche existiert,
    um einer Anzahl Goals zu ordnen. Diese Goals sind gewählt und an Phasen
    gebunden abhängig vom entsprechenden Packetierungstyp des Projektes in
    Verarbeitung. In Maven gibt es drei Standard Lebenszyklen:
    <literal>clean</literal>, <literal>default</literal> (auch
    <literal>build</literal> genannt) und <literal>site</literal>. Dieses
    Kapitel wird erläutern, wie Maven Goals an Lebenszyklusphasen bindet und
    wie Lebenszyklen angepasst werden können. Die Standard Lebenszyklusphasen
    werden ebenfalls eingeführt. </para>

    <section id="lifecycle-sect-clean">
      <title>Lebenszyklus: clean </title>

      <para>Der erste Lebenszyklus für welchen Sie sich interessieren werden
      ist zugleich der einfachste Lebenszyklus von Maven. Der Aufruf von
      <command>mvn clean</command> started den Lebenszyklus
      <varname>clean</varname> welcher aus drei Phasen besteht:</para>

      <itemizedlist>
        <listitem>
          <para><varname>pre-clean</varname></para>
        </listitem>

        <listitem>
          <para><varname>clean</varname></para>
        </listitem>

        <listitem>
          <para><varname>post-clean</varname></para>
        </listitem>
      </itemizedlist>

      <para>Die interessante Phase des Lebenszyklus <varname>clean</varname>
      ist die Phase <varname>clean</varname>. Das Goal
      <varname>clean</varname> (<varname>clean:clean</varname>) des Plugins
      <varname>clean</varname> wird an die Phase <varname>clean</varname> des
      Lebenszyklus <varname>clean</varname> gebunden. (Noch ganz sauber oder
      was!?!) Das Goal <varname>clean:clean</varname> löscht die Ergebnisse
      des vorgehenden Builds indem es das Zielverzeichnis löscht. Sollten Sie
      das Zielverzeichnis nicht weiter angepasst haben, so ist dieses
      Zielverzeichnis das Verzeichnis <filename>\${basedir}/target</filename>
      wie dies im Super POM definiert ist. Die Ausführung des Goals
      <varname>clean:clean</varname> wird nicht direkt mit dem Aufruf
      <command>mvn clean:clean</command> gestartet, statt dessen wird die
      Phase <varname>clean</varname> des Lebenszyklus zur Ausführung gebracht.
      Die Ausführung der Phase <varname>clean</varname> ermöglicht Maven auch
      Goals welche an die Phase <varname>pre-clean</varname> gebunden sind
      auszuführen. </para>

      <para>Ein Beispiel: nehmen wir an Sie möchten das Goal
      <varname>antrun:run</varname> während der Phase
      <varname>pre-clean</varname> anstossen, um eine Nachricht auszugeben,
      oder um ein Archiv des Project Build Verzeichnis anzulegen bevor dieses
      gelöscht wird. Der Aufruf von <varname>clean:clean</varname> wird den
      Lebenszyklus gar nicht ausführen, jedoch wird die Angabe der Phase
      <varname>clean</varname> auslösen, dass die drei Lebenszyklusphasen bis
      zur Phase <varname>clean</varname> ausgeführt werden. <xref
      linkend="ex-trigger-pre-clean" /> (Beispiel 10.1: Auslösen eines Goals
      in der Phase pre-clean) zeigt beispielhaft eine Build Konfiguration
      welche das Goal <varname>antrun:run</varname> and die Phase
      <varname>pre-clean</varname> bindet um eine Warnung auszugeben, welche
      mitteilt, dass der Projektartefakt gelöscht werden soll. In diesem
      Beispiel wird das Goal <varname>antrun:run</varname> benutzt, um ein
      beliebiges Ant Kommando auszuführen um zu prüfen ob es den Artefakten
      gibt. Besteht der Artefakt und soll gelöscht werden, so wird dies auf
      der Konsole ausgegeben. </para>

      <example id="ex-trigger-pre-clean">
        <title>Auslösen eines Goals in der Phase pre-clean</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;... &lt;plugin&gt;
    &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;file-exists&lt;/id&gt;
        &lt;phase&gt;pre-clean&lt;/phase&gt;
        &lt;goals&gt;
          &lt;goal&gt;run&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
          &lt;tasks&gt;
            &lt;!-- adds the ant-contrib tasks (if/then/else used below) --&gt;
            &lt;taskdef resource="net/sf/antcontrib/antcontrib.properties" /&gt;
            &lt;available 
              file="\${project.build.directory}/\${project.build.finalName}.\${project.packaging}"
              property="file.exists" value="true" /&gt;

            &lt;if&gt;
              &lt;not&gt;
                &lt;isset property="file.exists" /&gt;
              &lt;/not&gt;
              &lt;then&gt;
                &lt;echo&gt;No
                  \${project.build.finalName}.\${project.packaging} to
                  delete&lt;/echo&gt;
              &lt;/then&gt;
              &lt;else&gt;
                &lt;echo&gt;Deleting
                  \${project.build.finalName}.\${project.packaging}&lt;/echo&gt;
              &lt;/else&gt;
            &lt;/if&gt;
          &lt;/tasks&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;ant-contrib&lt;/groupId&gt;
        &lt;artifactId&gt;ant-contrib&lt;/artifactId&gt;
        &lt;version&gt;1.0b2&lt;/version&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/plugin&gt;
  &lt;/plugins&gt;
  &lt;/build&gt; 
&lt;/project&gt;
</programlisting>

        <para>Das Ausführen von <command>mvn clean</command> auf einem Projekt
        mit der oben gegebenen Build Konfiguration wird eine Ausgabe ähnlich
        der unten wiedergegebenen erzeugen. </para>
      </example>

      <screen>[INFO] Scanning for projects...
[INFO] ----------------------------------------------------------------------
[INFO] Building Your Project
[INFO]    task-segment: [clean]
[INFO] ----------------------------------------------------------------------
[INFO] [antrun:run {execution: file-exists}]
[INFO] Executing tasks
     [echo] Deleting your-project-1.0-SNAPSHOT.jar
[INFO] Executed tasks
[INFO] [clean:clean]
[INFO] Deleting directory ~/corp/your-project/target
[INFO] Deleting directory ~/corp/your-project/target/classes
[INFO] Deleting directory ~/corp/your-project/target/test-classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 second
[INFO] Finished at: Wed Nov 08 11:46:26 CST 2006
[INFO] Final Memory: 2M/5M
[INFO] ------------------------------------------------------------------------
</screen>

      <para>Zusätzlich zur Möglichkeit Maven so zu konfigurieren, dass es ein
      Goal während der Phase <varname>pre-clean</varname> ausführt wird, kann
      man das Clean Plugin so anzupassen, dass es Dateien über denen des
      Zielverzeichnisses hinaus löscht. Sie können das Plugin so
      konfigurieren, dass es bestimmte in einer Aufzählung angegebene Dateien
      löscht. Das unten aufgeführte Beispiel konfiguriert
      <varname>clean</varname> so, dass es unter Einsatz der standard Ant
      Wildcards (* und **) alle <filename>.class</filename> Dateien in einem
      Verzeichnis mit dem Namen <varname>target-other/</varname> löscht</para>

      <para><example>
          <title>Anpassen des Verhaltens des Clean Plugin</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;filesets&gt;
            &lt;fileset&gt;
              &lt;directory&gt;target-other&lt;/directory&gt;
              &lt;includes&gt;
                &lt;include&gt;*.class&lt;/include&gt;
              &lt;/includes&gt;
            &lt;/fileset&gt;
          &lt;/filesets&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>
        </example></para>
    </section>

    <section id="lifecycle-sect-default">
      <title>Standard Lebenszyklus: default</title>

      <para>Die meisten Maven Benutzer sind mit dem Standardlebenszyklus
      vertraut. Dieser bildet das algemeine Modell des Build Prozesses einer
      Software Applikation ab. Die erste Phase ist <varname>validate</varname>
      und die letzte Phase <varname>deploy</varname>. Die Phasen des Maven
      Standard Lebenszyklus sind in <xref linkend="tbl-default-lifecycle" />
      (Tabelle 10.1: Maven Lebenszyklusphasen) aufgeführt. </para>

      <table id="tbl-default-lifecycle">
        <title>Maven Lebenszyklusphasen</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Lebenszyklus Phase</entry>

              <entry>Beschreibung</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>validate</entry>

              <entry>Validieren, dass ein Projekt komplett ist, und dass alle
              notwendigen Informationen um einen Build zu erstellen verfügbar
              sind. </entry>
            </row>

            <row>
              <entry>generate-sources</entry>

              <entry>Generieren jeglicher Quellen welche benötigt werden um in
              ein Kompilat eingefügt zu werden. </entry>
            </row>

            <row>
              <entry>process-sources</entry>

              <entry>Verarbeiten der Quellen, zum Beispiel um Werte zu Filtern
              </entry>
            </row>

            <row>
              <entry>generate-resources</entry>

              <entry>Generieren der Ressourcen welche einem Paket beigefügt
              werden</entry>
            </row>

            <row>
              <entry>process-resources</entry>

              <entry>Kopieren und Verarbeiten der Ressourcen, Ablage in das
              Zielverzeichnis bereit um zu packetieren. </entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>Kompilieren der Quellen des Projektes. </entry>
            </row>

            <row>
              <entry>process-classes</entry>

              <entry>Nachverarbeitung der generierten Dateien der
              Kompilierung, zum Beispiel um Bytecode Modifikationen
              einzufügen. </entry>
            </row>

            <row>
              <entry>generate-test-sources</entry>

              <entry>Generieren von Test Quellcode welcher in das Kompilat
              eingefügt werden muss. </entry>
            </row>

            <row>
              <entry>process-test-sources</entry>

              <entry> Verarbeiten des Test Quellcodes, z.B. um Werte zu
              filtern </entry>
            </row>

            <row>
              <entry>generate-test-resources</entry>

              <entry>Erstellen der Test Ressourcen</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>Verarbeiten und Kopieren der Ressourcen in das
              Test-Zielverzeichnis</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>Kompilieren der Test Quelldateien in das Test
              Zielverzeichnis</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>Abarbeiten der Tests unter Einsatz eines geeigneten Unit
              Test Frameworks. Diese Tests sollten nicht voraussetzen, dass
              der Code Packetiert und Deployed wird. </entry>
            </row>

            <row>
              <entry>prepare-package</entry>

              <entry>Ausführen jeglicher notwendiger Schritte, um die
              Packetierung vorzubereiten, dies führt oftmals zu einer
              unpacketierten verarbeiteten Version des Pakets (Teil von Maven
              2.1+)</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>Paketieren des Kompilates in ein verteilbares Format wie
              z.B. <acronym>JAR</acronym>, <acronym>WAR</acronym> oder
              <acronym>EAR</acronym> </entry>
            </row>

            <row>
              <entry>pre-integration-test</entry>

              <entry>Ausführen vorbereitender Schritte für Integrationstests.
              Dies kann die Erstellung des notwendigen Testumfeldes umfassen.
              </entry>
            </row>

            <row>
              <entry>integration-test</entry>

              <entry>Verarbeiten und deployen des Packages in eine Umgebung in
              welcher Integrationstests ausgeführt werden können. </entry>
            </row>

            <row>
              <entry>post-integration-test</entry>

              <entry>Ausführen von abschliessenden Schritten nachdem die
              Integrationstests ausgeführt wurden, dies kann auch die
              Bereinigung der Umgebung beinhalten. </entry>
            </row>

            <row>
              <entry>verify</entry>

              <entry>Jegliche Prüfungen ausführen um sicherzustellen dass das
              Package die erforderlichen Kriterien erfüllt. </entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>Installieren des Packages in das lokale Repository um
              dort lokal als Abhängigkeit für andere Projekte bereitzustehen.
              </entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>Kopiert das endgültige Paket in das ferne Repository um
              dieses anderen Entwicklern und Projekten bereitzustellen. Dieser
              Schritt ist gewöhnlich nur bei offiziellen Versionen von
              Bedeutung. </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-site">
      <title>Lebenszyklus: site </title>

      <para>Maven kann mehr als nur Software Artefakte von Projekten
      erstellen. Es kann auch Projektdokumentation und Reports bezüglich dem
      Projekt oder eine Reihe von Projekten, erstellen. Projektdokumentation
      und Site Generierung haben einen eigenen Lebenszyklus zugeordnet,
      welcher vier Phasen kennt: </para>

      <orderedlist>
        <listitem>
          <para>pre-site</para>
        </listitem>

        <listitem>
          <para>site</para>
        </listitem>

        <listitem>
          <para>post-site</para>
        </listitem>

        <listitem>
          <para>site-deploy</para>
        </listitem>
      </orderedlist>

      <para>Die an den Lebenszyklus <varname>site</varname> gebundenen Goals
      sind: </para>

      <orderedlist>
        <listitem>
          <para>site - site:site</para>
        </listitem>

        <listitem>
          <para>site-deploy -site:deploy</para>
        </listitem>
      </orderedlist>

      <para>Die Art der Packetierung ändert im allgemeinen diesen Lebenszyklus
      nicht, da Packetierungstypen sich primär mit der Artefakt Erzeugung
      befassen, nicht mit der Art des Sites der Generiert wird. Das Site
      Plugin started die Ausführung der Doxia Dokument Generierung und anderer
      Report generierender Plugins. Sie können einen Site eines Maven Projekts
      erstellen indem Sie das folgende Kommando absetzen: </para>

      <screen>$ <command>mvn site</command>
</screen>

      <para>Die Generierung von Sites mittels Maven wird in <xref
      linkend="site-generation" /> (Kapitel 15: Site Generierung) weiter
      vertieft. </para>
    </section>
  </section>

  <section id="lifecycle-sect-package-specific">
    <title>Package-spezifische Lebenszyklen </title>

    <para>Die genauen Goals welche an eine Phase gebunden werden sind bestimmt
    durch die Menge der Goals welche durch die projektspezifische Packetierung
    festgelegt wird. Ein Projekt welches vom Packetierungs Typ
    <varname>jar</varname> ist hat einen anderen Standardsatz Goals als das
    ein Projekt vom Typ <varname>war</varname> hat. Das Element
    <varname>packaging</varname> beeinflusst den Satz der Goals welche beim
    Build abgearbeitet werden müssen. Um Ihnen beispielhaft vorzuführen wie
    sehr <varname>packaging</varname> den Build beeinflusst, hier zwei
    Projekte: Eines mit <varname>packaging</varname>-Element
    <varname>pom</varname> und eines vom Typ <varname>jar</varname>. Das
    Projekt vom Typ <varname>pom</varname> wird das Goal
    <varname>site:attach-descriptor</varname> in der Phase
    <varname>packaging</varname> abarbeiten, das Projekt vom Typ
    <varname>jar</varname> wird satt dessen das Goal
    <varname>jar:jar</varname> abarbeiten. </para>

    <para>The following sections describe the lifecycle for all built-in
    packaging types in Maven. Use these sections to find out what default
    goals are mapped to default lifecycle phases.</para>

    <para>Der folgende Abschnitt beschreibt den Lebenszyklus aller
    standardmässig verfügbaren Package Typen in Maven. Benutzen Sie diesen
    Abschnitt als Referenz um herauszufinden welche Goals standardmässig an
    welche Phase gebunden werden. </para>

    <section id="lifecycle-sect-jar">
      <title>jar </title>

      <para><acronym>JAR</acronym> ist der Standard Paketierungstyp, es ist
      der am häufigsten benutzte und die am meisten in Lebenszyklen
      angetroffene Konfiguration. Die Standard Goals des
      <acronym>JAR</acronym> Lebenszyklus sind in <xref
      linkend="tbl-jar-lifecycle" /> (Tabelle 10.2: Standard Goals des JAR
      Packaging) aufgeführt.</para>

      <table id="tbl-jar-lifecycle">
        <title>Standard Goals des JAR Packaging</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Lebesnzyklus Phase</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>jar:jar</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-pom">
      <title>pom </title>

      <para><acronym>POM</acronym> ist der einfachste Paketierungstyp. Der
      generierte Artefakt ist sich selbst, kein <acronym>JAR</acronym>,
      <acronym>WAR</acronym> oder <acronym>EAR</acronym>. Es gibt keinen Code
      zu Testen oder Kompilieren, und es gibt auch keine Ressourcen zu
      verarbeiten. Die Standard Goals des <acronym>POM</acronym> Lebenszyklus
      sind in <xref linkend="tbl-pom-lifecycle" /> (Tabelle 10.3: Standard
      Goals des POM Packaging) aufgeführt: </para>

      <table id="tbl-pom-lifecycle">
        <title>Standard Goals des POM Packaging</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Lebenszyklus Phase</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>package</entry>

              <entry>site:attach-descriptor</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-plugin-lifecycle">
      <title> plugin</title>

      <para>Dieser Paketierungstyp ist ähnlich dem der <acronym>JAR</acronym>
      Packetierung mit drei Unterschieden:
      <varname>plugin:descriptor</varname>,
      <varname>plugin:addPluginArtifactMetadata</varname>, und
      <varname>plugin:updateRegistry</varname>. Diese Goals generieren eine
      Descriptor Datei und führen gewisse Änderungen an den Repository Daten
      aus. Die Standard Goals des <varname>plugin</varname> Lebenszyklus sind
      in <xref linkend="tbl-plugin-lifecycle" /> (Tabelle 10.4: Standard Goals
      des plugin Packaging) aufgeführt: </para>

      <table id="tbl-plugin-lifecycle">
        <title>Standard Goals des plugin Packaging</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Lebenszyklus Phase</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>generate-resources</entry>

              <entry>plugin:descriptor</entry>
            </row>

            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>jar:jar, plugin:addPluginArtifactMetadata</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install, plugin:updateRegistry</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-ejb">
      <title>ejb </title>

      <para>Enterprise Java Beans (<acronym>EJB</acronym>s) sind eine häufing
      angewandte Technologie für die Modell getriebene Entwicklung von
      Enterprise Java Applikationen. Maven unterstützt <acronym>EJB</acronym>
      2 und <acronym>EJB</acronym> 3, obschon man das Plugin speziell
      konfigurieren muss um <acronym>EJB</acronym> 3 zu unterstützen.
      Standardmässig wird <acronym>EJB</acronym> 2.1 umgesetzt, wobei das
      Plugin nach bestimmten <acronym>EJB</acronym> Konfigurationsdateien
      sucht. Die Standard Goals des <varname>ejb</varname> Lebenszyklus sind
      in <xref linkend="tbl-ejb-lifecycle" /> (Tabelle 10.5: Standard Goals
      des ejb Packaging) aufgeführt: </para>

      <table id="tbl-ejb-lifecycle">
        <title>Standard Goals des ejb Packaging</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Lebenszyklus Phase</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>ejb:ejb</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-war">
      <title>war </title>

      <para>Der Paketeierungstyp <varname>war</varname> ist ähnlich dem des
      Types <varname>jar</varname> oder <varname>ejb</varname>. Die Ausnahme
      hierbei ist das Goal <varname>war:war</varname>. Bitte beachten Sie,
      dass das <varname>war</varname> Plugin eine <filename>web.xml</filename>
      Konfigurationsdatei im Verzeichnis
      <filename>src/main/webapp/WEB-INF</filename> voraussetzt. Die Standard
      Goals des <varname>war</varname> Lebenszyklus sind in <xref
      linkend="tbl-war-lifecycle" /> (Tabelle 10.6: Standard Goals des war
      Packaging) aufgeführt: </para>

      <table id="tbl-war-lifecycle">
        <title>Standard Goals des war Packaging</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Lebenszyklus Phase</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>war:war</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-ear">
      <title>ear</title>

      <para><acronym>EAR</acronym>s sind wohl das einfachste <acronym>Java
      EE</acronym> Konstrukt, bestehen Sie ja lediglich aus der Deployment
      Beschreibungsdatei (Descriptor) <filename>application.xml</filename>,
      Ressourcen und einigen Modulen. Das <varname>ear</varname> Plugin hat
      besitzt ein Goal mit dem Namen
      <varname>generate-application.xml</varname> welche die
      <varname>applicaiton.xml</varname> Datei auf der Basis des POM
      generiert. Die Standard Goals des <varname>ear</varname> Lebenszyklus
      sind in <xref linkend="tbl-ear-lifecycle" /> (Tabelle 10.7: Standard
      Goals des <varname>ear</varname> Packaging) aufgeführt: </para>

      <table id="tbl-ear-lifecycle">
        <title>Standard Goals des POM Packaging</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Lebenszyklus Phase</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>generate-resources</entry>

              <entry>ear:generate-application-xml</entry>
            </row>

            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>ear:ear</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-other-packaging">
      <title>Andere Packetierungs Typen</title>

      <para>Dies ist keine abschliessende Liste aller für Maven verfügbarer
      Paketierungstypen. Es bestehen eine ganze Anzahl Paketierungs Formate
      verfügbar mittels externer Projekte und Plugins: der Typ native archive
      (<acronym>NAR</acronym>), die Typen <acronym>SWF</acronym> und
      <acronym>SWC</acronym> für Projekte welche Adobe Flash und Flex Inhalte
      erzeugen und viele andere. Sie können ebenfalls eigene Benutzer
      spezifische Paketierungs Typen definieren und den standardmässigen
      Lebenszyklus Ihren spezifischen Bedürfnissen anpassen. </para>

      <para>Um einen derart angepassten Paketierungstypen einzusetzen braucht
      es zwei Dinge: ein Plugin welches den angepassten Lebenszyklus definiert
      und ein Repository welches dieses Plugin beinhaltet. Manche angepassten
      Paketierungs Typen sind in Plugins definiert und über das zentrale
      Repository verfügbar. Hier ein Beispiel eines Projekts welches sich auf
      das Israfil Flex Plugin stützt und einen benutzerdefinierten
      Paketierungstyp <acronym>SWF</acronym> benutzt um die Ausgabe aus Adobe
      Flex Quellen zu erstellen. </para>

      <para><example>
          <title>Benutzerdefinierter Packetierungs -Type für Adobe Flex
          (SWF)</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;packaging&gt;swf&lt;/packaging&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;net.israfil.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;maven-flex2-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.4-SNAPSHOT&lt;/version&gt;
        &lt;extensions&gt;true&lt;/extensions&gt;
        &lt;configuration&gt;
          &lt;debug&gt;true&lt;/debug&gt;
          &lt;flexHome&gt;\${flex.home}&lt;/flexHome&gt;
          &lt;useNetwork&gt;true&lt;/useNetwork&gt;
          &lt;main&gt;org/sonatype/mavenbook/Main.mxml&lt;/main&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  ...
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>In <xref linkend="writing-plugins-sect-plugins-lifecycle" />
      (Abschnitt 17.6 Plugins und der Maven Lebenszyklus) führen wir aus, wie
      Sie Ihren eigenen Paketierungstypen mit angepasstem Lebenszyklus
      erstellen. Das Beispiel sollte Ihnen aufzeigen was notwendig ist, um
      einen angepassten Paketierungstypen einzusetzen. Das einzige was Sie
      tatsächlich dazu beitragen müssen ist, das Plugin welches den
      angepassten Paketierungstyp mitbringt zu referenzieren. Das Israfil FLex
      Plugin ist ein Drittpartei Maven Plugin welches von Google Code
      bereitgehalten wird. Für weitere Informationen bezüglich des Plugins,
      oder den Schritten die notwendig sind um Adobe Flex zu Kompilieren,
      wenden Sie sich bitte an <ulink
      url="http://code.google.com/code.google.com/p/israfil-mojo">http://code.google.com/code.google.com/p/israfil-mojo</ulink>.
      Das Plugin liefert die folgenden Lebenszyklen des <acronym>SWF</acronym>
      Packetierungs Typ. </para>

      <table>
        <title>Standard Lebenszyklus für SWF Packetierung </title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Lebenszyklus Phase</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>compile</entry>

              <entry>flex2:compile-swc</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>

  <section id="lifecycle-sect-common-goals">
    <title>Gebräuchliche Lebenszyklus Goals </title>

    <para>Viele der Paketierungs-Lebenszyklen haben ähnliche Goals. Wenn Sie
    die Goals des <varname>war</varname> und des <varname>jar</varname>
    Lebenszyklus vergleichen, so werden Sie feststellen, dass diese sich
    lediglich in der Phase <varname>package</varname> unterscheiden. Die Phase
    <varname>package</varname> des Lebenszyklus <varname>war</varname> ruft
    <varname>war:war</varname> auf, die des Lebenszyklus
    <varname>jar</varname> ruft <varname>jar:jar</varname> auf. Die meisten
    der Lebenszyklen mit welchen Sie in Kontakt kommen werden teilen sich
    einige gemeinsame Lebenszyklus Goals um Ressourcen zu Managen, Tests
    Abzuarbeiten sowie Quellen zu Kompilieren. In diesem Abschnitt wollen wir
    nun einige dieser gemeinsamen Lebenszyklus Goals genauer betrachten.
    </para>

    <section id="lifecycle-sect-process-resources-phase">
      <title>Ressourcen Verarbeiten </title>

      <para>Die meisten Lebenszyklen binden das Goal
      <varname>resources:resources</varname> an die Phase
      <varname>process-resources</varname>. Diese Phase „verarbeitet“
      Ressourcen und kopiert diese in das Zielverzeichnis. So Sie dieses nicht
      angepasst haben, gelten die im Super POM festegelegten
      Standardverzeichnisse, das heisst, Maven kopiert die Dateien von
      <filename>\${basedir}/src/main/resources</filename> nach
      <filename>\${project.build.outputDirectory}</filename>. Zusätzlich zu der
      reinen Kopieraktion kann Maven auch die Ressourcen filtern, d.h. Sie
      können gewisse Token in den Dateien ersetzen. Genau wie Variablen
      innerhalb der <acronym>POM</acronym> Datei mittels <varname>\${ …
      }</varname> markiert sind, so können Sie die gleiche Syntax einsetzen um
      Variablen innerhalb von Ressourcen zu referenzieren. Im Zusammenspiel
      mit Build-Profilen kann diese Eigenschaft dazu benutzt werden, um Builds
      für unterschiedliche Zielplattformen zu erstellen. Dies trifft man
      häufig in Umgebungen an, welche für das gleiche Projekt unterschiedliche
      Builds für das Development, Test, Integrationstest und Produktion
      erstellen müssen. Bezüglich weiter Informationen zu Build-Profilen
      verweisen wir auf <xref linkend="profiles" /> (Kapitel 11: Build
      Profile).</para>

      <para>Um Ressource Filterung zu veranschaulichen, stellen Sie sich vor,
      Sie habe ein Projekt mit einer <acronym>XML</acronym>-Datei unter
      <filename>/src/main/resources/META-INF/services.xml</filename>. Hierbei
      möchten Sie eine Konfigurationseinstellung in eine Property-Datei
      auslagern. In anderen Worten, Sie möchten zum Beispiel die Werte der
      <acronym>JDBC URL</acronym>, <emphasis>Benutzername</emphasis> und
      <emphasis>Passwort</emphasis> der Datenbank nicht direkt in der
      <filename>service.xml</filename> Datei ablegen. Statt dessen möchten Sie
      eine Property Datei mit den variablen Werten Ihres Programms anlegen.
      Das ermöglicht Ihnen, alle Konfigurationsparameter in einer Datei
      zusammenzufassen, um diese an einem Ort zu ändern sobald Sie von einer
      Umgebung in eine andere wechseln. Sehen Sie sich also zuallererts den
      Inhalt der entsprechenden Datei <filename>services.xml</filename> unter
      <filename>/src/main/resources/META-INF</filename> an: </para>

      <para><example>
          <title>Einsatz von Properties in den Projektressourcen </title>

          <programlisting language="xml">&lt;service&gt;
  &lt;!-- This URL was set by project version \${project.version} --&gt;
  &lt;url&gt;\${jdbc.url}&lt;/url&gt;
  &lt;user&gt;\${jdbc.username}&lt;/user&gt;
  &lt;password&gt;\${jdbc.password}&lt;/password&gt;
&lt;/service&gt;
</programlisting>
        </example></para>

      <para>Die in der <acronym>XML</acronym> Datei zum Einsatz kommende
      Syntax ist die selbe welche bereits in der <acronym>POM</acronym> Datei
      zum Einsatz kommt. Die erste zum Einsatz kommende Variable ist sogar
      eine Maven-implizite Variable welche vom <acronym>POM</acronym>
      bereitgestellt wird. Die Variable <varname>projekt</varname> erlaubt den
      Zugriff auf die Werte des <acronym>POM</acronym>. Die folgenden drei
      Referenzen sind <varname>jdbc.url</varname>,
      <varname>jdbc.username</varname> und <varname>jdbc.passwort</varname>.
      Diese benutzerdefinierten Variablen wurden in der Property Datei unter
      <filename>src/main/filters/default.properties</filename> definiert.
      </para>

      <example>
        <title>Datei <filename>default.properties</filename> unter
        <filename>src/main/filters</filename></title>

        <programlisting>jdbc.url=jdbc:hsqldb:mem:mydb
jdbc.username=sa
jdbc.password=
</programlisting>
      </example>

      <para>Um Ressourcenfilterung der Datei
      <filename>default.properties</filename> einzustellen, müssen innerhalb
      des <acronym>POM</acronym> zwei Dinge gesetzt werden: eine Liste der
      properties-Dateien innerhalb des Elements <varname>filters</varname> der
      Buildkonfiguration, sowie eine Maven Einstellung dass das
      Ressourcenverzeichnis der Filterung unterliegt. Standardmässig ist
      dieses Verhalten abgestellt und Ressourcen werden direkt in das
      Ausgabeverzeichnis kopiert, oder Maven übergeht diesen Schritt ganz.
      Diese Einstellung ist standardmässig so gewählt, damit es nicht
      vorkommt, dass ohne ersichtlichen Grund alle bestehenden
      <varname>\${...}</varname>-Referenzen ersetzt werden, welche Sie gar
      nicht ersetzen wollten. </para>

      <para><example>
          <title>Ressourcen Filtern (Ersetzen von Properties)</title>

          <programlisting language="xml">&lt;build&gt;
  &lt;filters&gt;
    &lt;filter&gt;src/main/filters/default.properties&lt;/filter&gt;
  &lt;/filters&gt;
  &lt;resources&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/resources&lt;/directory&gt;
      &lt;filtering&gt;true&lt;/filtering&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
&lt;/build&gt;
</programlisting>
        </example></para>

      <para>Wie mit allen Verzeichnissen unter Maven, ist es nicht Bedingung,
      das das Ressourcenverzeichnis unbedingt unter
      <filename>src/main/ressources</filename> liegt. Das ist lediglich der
      entsprechende Standardpfad wie er im Super <acronym>POM</acronym>
      festgelegt ist. Ebenfalls ist es gut zu wissen, dass Sie nicht gezwungen
      sind, alle Ihre Ressourcen in ein einzigen Verzeichniss zu
      konsolidieren. Sie können Ressourcen auch in getrennten Verzeichnissen
      unter <filename>src/main</filename> ablegen. Nehmen Sie einmal an, Sie
      arbeiten an einem Projekt mit hunderten von
      <acronym>XML</acronym>-Dokumenten und hunderten von Bildern. Anstatt nun
      alle diese Dateien unter dem Verzeichnis
      <filename>src/main/ressources</filename> gemischt abzulegen, ist es
      möglich, zwei Verzeichnisse <filename>src/main/xml</filename> und
      <filename>src/main/images</filename> anzulegen um die Inhalte dort
      abzulegen. Um weitere Verzeichnisse Ihrer Liste von
      Ressourceverzeichnissen zuzufügen, müssen Sie folgendes Element
      <varname>resource</varname> Ihrer Buildkonfiguration zufügen: </para>

      <example>
        <title>Festlegen zusätzlicher Ressource Verzeichnisse</title>

        <programlisting language="xml">&lt;build&gt;
  ...
  &lt;resources&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/resources&lt;/directory&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/xml&lt;/directory&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/images&lt;/directory&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
  ...
&lt;/build&gt;</programlisting>
      </example>

      <para>Sollten Sie ein Projekt erstellen, welches eine
      Befehlszeilenapplikation erzeugt, so finden Sie sich oftmals in einer
      Situation wieder, in welcher Sie einfache Shell Skripte erstellen,
      welche ein Jar-Dateien des Builds referenzieren. Sollten Sie dann das
      Assembly Plugin benutzen um ein Distributionspaket in Form eines
      <acronym>ZIP</acronym>- oder <acronym>TAR</acronym>-Archivs zu
      erstellen, so macht es Sinn, alle ihre Skripte in einem Verzeichniss wie
      etwa <filename>src/main/command</filename> zusammenzufassen. Im
      folgenden Ausschnitt einer <acronym>POM</acronym>
      Ressourcenkonfiguration können Sie sehen, wie wir Ressourcenfilterung
      und eine Referenz auf eine Projektvariable benutzen können, um den
      endgültigen Ausgabenamen des jar-Archives zu definieren. Weitere
      Informationen bezüglich des Maven Assembly Plugins finden Sie in <xref
      linkend="assemblies" /> (Kapitel 12: Maven Assemblies). </para>

      <para><example id="ex-filter-script">
          <title>Filterung von Skript Ressourcen</title>

          <programlisting language="xml">&lt;build&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;simple-cmd&lt;/artifactId&gt;
  &lt;version&gt;2.3.1&lt;/version&gt;
  ...
  &lt;resources&gt;
    &lt;resource&gt;
      &lt;filtering&gt;true&lt;/filtering&gt;
      &lt;directory&gt;\${basedir}/src/main/command&lt;/directory&gt;
      &lt;includes&gt;
        &lt;include&gt;run.bat&lt;/include&gt;
        &lt;include&gt;run.sh&lt;/include&gt;
      &lt;/includes&gt;
      &lt;targetPath&gt;\${basedir}&lt;/targetPath&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
      &lt;directory&gt;\${basedir}/src/main/resources&lt;/directory&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
  ...
&lt;/build&gt;</programlisting>
        </example></para>

      <para>Der Aufruf von <command>mvn process-resources</command> dieses
      Projektes erzeugt zwei Dateien, <filename>run.sh</filename> sowie
      <filename>run.bat</filename>, beide unter
      <filename>\${basedir}</filename>. Wir haben innerhalb eines Elements
      <varname>resource</varname> diese zwei Dateien herausgepickt, Filterung
      eingestellt, und den Zielpfad (<filename>targetPath</filename>) auf
      <filename>\${basedir}</filename> gesetzt. In einem zweiten Elememt
      Resource haben wir definiert, dass die Ressourcen des Standard
      Ressourcenpfades in das Standardausgabeverzeichnis kopiert werden ohne
      diese zu filtern. <xref linkend="ex-filter-script" /> (Beispiel 10.8:
      Filterung von Skript Ressourcen) zeigt beispielhaft auf, wie Sie zwei
      Resourceverzeichnisse bestimmen und diese mit unterschiedlichen
      Filterkriterien sowie Zielverzeichnissen versehen. Das Projekt des <xref
      linkend="ex-filter-script" /> (Beispiels 10.8: Filterung von Skript
      Ressourcen) würde eine Datei <filename>run.bat</filename> unter
      <filename>src/main/command</filename> mit folgendem Inhalt enthalten:
      </para>

      <programlisting>@echo off
java -jar \${project.build.finalName}.jar %*
</programlisting>

      <para>Nach der Ausführung von <command>mvn process-resources</command>,
      erscheint eine Datei <filename>run.bat</filename> im Verzeichnis
      <varname>\${basedir}</varname> mit folgendem Inahlt: </para>

      <programlisting>@echo off
java -jar simple-cmd-2.3.1.jar %*
</programlisting>

      <para>Die Möglichkeit unterschiedliche Filter für speziefische
      Untergruppen von Ressourcen zu setzen, ist ein weiterere Grund weshalb
      Projekte mit vielen verschiedenen Arten von Artefakten es oftmals als
      hilfreich erachten, diese in verschiedenen Verziechnissen abzulegen. Die
      Alternative zum Ablegen verschiedener Ressourcetypen in
      unterschiedlichen Verzichnissen ist der Einsatz von komplexeren Sätzen
      von Ein- und Ausschlusskriterien, um die entsprechenden Ressource
      Dateien welche einem Muster genügen, zu spezifizieren. </para>
    </section>

    <section id="lifecycle-sect-compile-phase">
      <title>compile</title>

      <para>Die allermeisten Lebenszyklen binden das Goal
      <varname>compile</varname> des Compiler Plugin an die Phase
      <varname>compile</varname>. Diese Phase ruft
      <varname>compile:compile</varname> auf, welches konfiguriert ist, alle
      Quellen zu verarbeiten und den resultierenden Bytecode im Build
      Ausgabeverzeichniss abzulegen. Sollten Sie die Standardeinstellungen des
      SuperPOM nicht angepasst haben, so wird
      <varname>compile:compile</varname> alle Quellen unter
      <filename>src/main/java</filename> verarbeiten und das Ergebnis unter
      <filename>/target/classes</filename> ablegen. Das Compile Plugin ruft
      <productname>javac</productname> auf, und hat die Standardeinstellungen
      1.3 und 1.1, in anderen Worten, das Compiler Plugin geht davon aus, dass
      Sie Java 1.3 konformen Code erzeugen und diesen an eine Java Virtual
      Machine 1.1 addressieren. Sollten Sie diese Einstellungen verändern
      wollen, so müssen sie die Ziel und Quellkonfiguration ihres Projektes
      dem Compiler Plugin mit auf den Weg geben. Sie tun dies mittels einem
      Eintrag in der <acronym>POM</acronym> Datei wie dies in <xref
      linkend="ex-compilesrc-target" /> (Beispiel 10.9: Einstellen der Quell-
      und Zielkonfiguration des Kompiler Plugins). </para>

      <para><example id="ex-compilesrc-target">
          <title>Einstellen der Quell- und Zielkonfiguration des Compiler
          Plugins</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    ...
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.5&lt;/source&gt;
          &lt;target&gt;1.5&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    ...
  &lt;/build&gt;
  ...
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Beachten Sie, dass wir das Compiler Plugin konfigurieren, und
      nicht das spezifische Goal <varname>compile:compile</varname>. Um nur
      das spezifische Goal <varname>compile:compile</varname> zu
      konfigurieren, müssten wir das Element <varname>configuration</varname>
      unterhalb eines Elements <varname>execution</varname> des Goals
      <varname>compile:compile</varname> spezifizieren. Wir haben aber das
      Quell-und Zielverzeichnis des Compile Plugins konfiguriert, denn wir
      wollten nicht nur dieses eine Goal konfigurieren. Das Compiler Plugin
      kommt ebenfalls zum Einsatz, wenn Maven die Testquellen mittels dem Goal
      <varname>compile:testCompile</varname> verarbeitet. Die Definition des
      Plugin erlaubt uns die Konfiguration einmal auf der Pluginebene für alle
      Goals vorzunehmen. </para>

      <para>Sollten Sie den Ort Ihrer Quelldateien umdefinieren müssen, so
      können Sie dies durch die Veränderung der Build Konfiguration erreichen.
      Sollten Sie zum Beispiel ihre Quellen unter
      <filename>src/java</filename> statt <filename>src/main/java</filename>
      ablegen, und sollten das Ergebnis unter <filename>classes</filename>
      anstatt <filename>target/classes</filename> ablegen wollen, so können
      Sie jederzeit die Standarwerte <varname>sourceDirectory</varname>
      (Quellverzeichnis) des SuperPOM übersteuern. </para>

      <example>
        <title>Übersteuern des Standard Quellverzeichnisses</title>

        <programlisting language="xml">&lt;build&gt;
  ...
  &lt;sourceDirectory&gt;src/java&lt;/sourceDirectory&gt;
  &lt;outputDirectory&gt;classes&lt;/outputDirectory&gt;
  ...
&lt;/build&gt;</programlisting>
      </example>

      <warning>
        <para>Obschon es Gründe geben mag die dafür sprechen, Maven ihren
        Wünschen bezüglich Verzeichnisstruktur anzupassen, so können wir hier
        nicht stark genug betonen, dass es besser ist Ihre eingene Struktur
        zugunsten der Maven Standardverzeichnisstruktur aufzugeben. Dies ist
        keinesfalls darin begründet, dass wir Sie von dieser Struktur bekehren
        wollen, sondern es ist einfacher für andere Entwickler, ihre
        Projektstruktur zu verstehen, sollte diese den grundlegenden
        Konventionen folgen. Vergessen Sie schon den Ansatz! - Tun Sie sich
        diesen Gefallen. </para>
      </warning>
    </section>

    <section id="lifecycle-sect-process-test-resources-phase">
      <title>Verarbeiten von Test Ressourcen </title>

      <para>Die Phase <varname>process-test-resources</varname> lässt sich
      kaum von der Phase <varname>process-ressources</varname> unterscheiden.
      Es gibt einige triviale Unterschiede des <acronym>POM</acronym>, alles
      andere ist gleich. Sie können Test Ressourcen filtern wie die anderen
      Ressourcen auch. Der standardmässige Ort der Testressourcen ist im Super
      POM mit <filename>src/test/resources</filename> gesetzt und das
      standardmässige Ausgabeverzeichnis von Testressourcen auf
      <filename>target/test-classes</filename> wie dies unter
      <filename>\${project.build.testOutputDirectory}</filename> definiert ist.
      </para>
    </section>

    <section id="lifecycle-sect-test-compile-phase">
      <title>Kompilieren der Test Klassen (testCompile) </title>

      <para>Die Phase <varname>test-compile</varname> ist beinahe identisch
      mit der Phase <varname>compile</varname>. Der einzige Unterschied ist,
      dass <varname>test-compile</varname> das Goal
      <varname>compile:testCompile</varname> anzieht, um Testquellen vom
      Quellverzeichnis anzuziehen und die Ausgabe im Test-Ausgabeverzeichnis
      abzulegen. Sollten Sie die Standardverzeichnisse des SuperPOM nicht
      übersteuert haben, so wird <varname>compile:Test</varname> die Sourcen
      aus dem Verzeichnis <filename>src/test/java</filename> in das
      Verzeichnis <varname>target/test-classes</varname> kompilieren. </para>

      <para>Wie mit den Quellverzeichnissen gilt, sollten Sie den Ort der Test
      Verzeichnisse ändern wollen, so können Sie dies tun indem Sie
      <filename>testSourceDirectory</filename> und
      <filename>testOutputDirectory</filename> anpassen. Sollten Sie
      Testquellen unter <filename>src-test/</filename> anstatt
      <filename>src/test/java</filename> ablegen und den Bytecode unter
      <filename>classes-test/</filename> anstatt
      <filename>target/test-classes</filename> ablegen wollen, so wüden Sie
      auf die folgende Konfiguration vornehmen. </para>

      <example>
        <title>Übersteuern des Ortes der Testquellen und -ausgabe</title>

        <programlisting language="xml">&lt;build&gt;
  ...
  &lt;testSourceDirectory&gt;src-test&lt;/testSourceDirectory&gt;
  &lt;testOutputDirectory&gt;classes-test&lt;/testOutputDirectory&gt;
  ...
&lt;/build&gt;</programlisting>
      </example>
    </section>

    <section id="lifecycle-sect-test-phase">
      <title>test </title>

      <para>Die meisten Lebenszyklen binden das Goal <varname>test</varname>
      des Surefire Plugin an die Phase <varname>test</varname>. Das Surefire
      Plugin ist das UnitTest Plugin von Maven. Das Standardverhalten des
      Surefire Plugin ist, nach allen Klassen welche im Test
      Quellenverzeichnis auf *Test enden zu suchen, um diese als <ulink
      url="http://www.junit.org">JUnit</ulink> Tests auszuführen. Das Surefire
      Plugin kann auch konfiguriert werden die Tests als <ulink
      url="http://www.testng.org">TestNG</ulink> Unit Test abzuarbeiten.
      </para>

      <para>Nach der Ausführung von <command>mvn test</command> sollten Sie
      feststellen können, das das Surefire Plugin eine Anzahl Reports unter
      <filename>target/surefire-reports</filename> ablegt. Dieses
      Reportverzeichnis beinhaltet zwei Dateien für jeden ausgeführten Test:
      eine <acronym>XML</acronym> Datei welche Informationen bezüglich des
      Tests enthält und eine Textdatei welche die Ausgabe des UnitTest
      enthält. Sollte ein Problem während der Phase <varname>test</varname>
      auftreten und ein Unit Test nicht bestehen, so können Sie die Ausgabe
      von Maven zusammen mit dieser Datei benutzen, um den Grund des Abbruchs
      zu finden. Dieses Verzeichnis <varname>surefire-reports/</varname> kommt
      ebenfalls zum Einsatz während der Site Generierung wobei eine einfach zu
      lesende Zusammenfassung der Unit Tests des Projektes erstellt wird.
      </para>

      <para>Sollten Sie an einem Projekt arbeiten, bei welchem einige
      abbrechende Unit Test bestehen, Sie möchten aber dennoch eine Ausgabe
      erzeugen, so müssen Sie das Surefire Plugin so konfigurieren, dass
      dieses die Ausführung beim Auftreten eines Fehlers nicht abbricht. Das
      Standardverhalten ist, dass der Build beim ersten auftreten eines Unit
      Test Fehlers abbricht. Um dieses Verhalten zu ändern, müssen Sie das
      Property <varname>testFailureIgnore</varname> des SureFire Plugin auf
      <varname>true</varname> setzen. </para>

      <example>
        <title>Konfiguration des Surefire Plugins um Testabbrüche zu
        ignorieren</title>

        <programlisting language="xml">&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
     &lt;configuration&gt;
       &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;
     &lt;/configuration&gt;
    &lt;/plugin&gt;
    ...
  &lt;/plugins&gt;
&lt;/build&gt;</programlisting>
      </example>

      <para>Sollten Sie die Tests komplett übergehen wollen, so können Sie
      dies durch den folgenden Aufruf erreichen: </para>

      <screen>$ mvn install -Dmaven.test.skip=true</screen>

      <para>Die Variable <varname>maven.test.skip</varname> beeinflusst
      beides, den Compiler und das Surefire Plugin. Geben Sie
      <varname>maven.test.skip=true</varname> an, so weisen Sie Maven an die
      Tests insgesamt zu ignorieren.</para>
    </section>

    <section id="lifecycle-sect-install-phase">
      <title>install </title>

      <para>Das Goal <varname>install</varname> des Install Plugin ist immer
      an die Lebenszyklusphase <varname>install</varname> gebunden. Das Goal
      <varname>install:install</varname> installiert den Artefakt in das
      lokale Repository. Sollten Sie ein Projekt mit der
      <varname>groupId</varname> von <varname>org.sonatype.mavenbook</varname>
      einen Artefakten mit <varname>artifactId</varname> von
      <varname>simple-test</varname> und einer <varname>version</varname> von
      <varname>1.0.2</varname> haben, so wird das Goal
      <varname>install:install</varname> das <acronym>JAR</acronym> von
      <filename>target/simple-test-1.0.2.jar</filename> in
      <filename>~/.m2/repository/org/sonatype/mavenbook/simple-test/1.0.2/simpletest-1.0.2.jar</filename>
      kopieren. Ist das Projekt ein Projekt vom Typ <acronym>POM</acronym>
      Pakageing, so wird das POM in das lokale Repository eingestellt. </para>
    </section>

    <section id="lifecycle-sect-deploy-phase">
      <title>deploy</title>

      <para>Das Goal <varname>deploy</varname> des Plugins Deploy wird
      gewöhnlich an die Lebenszyklusphase <varname>deploy</varname> gebunden.
      Diese Phase wird benutzt, um einen Artefakten in ein entferntes
      Repository einzustellen. Gewöhnlich geschiet dies um ein entferntes
      Repository bei einer Freigabe aktuell zu halten. Der Deployment Vorgang
      kann eine einfache Kopieraktion einer Datei darstellen, oder aber auch
      eine Übertragung einer Datei mittles <acronym>SCP</acronym> und einem
      publicKey. Deployment Einstellungen beinhalten gewöhnlich Zugangsdaten
      zu einem entfernten Repository, aus welchem Grund Deployment
      Einstellungen gewöhnlich nicht in der <filename>pom.xml</filename> Datei
      gehalten werden. Statt dessen gehen diese gewöhnlich in die
      benutzerspezifische Datei <filename>~/m2/settings.xml</filename>. Zu
      diesem Zeitpunkt reicht es zu wissen, das das Goal
      <varname>deploy:deploy</varname> an die Phase <varname>deploy</varname>
      gebunden ist und sich der Übertragung der Artefakten zu einem
      veröffentlichten Repository und dem damit verbundenen Update der
      Repository Informationen welche von einem solchen Vorgang betroffen sein
      könnten, annimmt. </para>
    </section>
  </section>
</chapter>
