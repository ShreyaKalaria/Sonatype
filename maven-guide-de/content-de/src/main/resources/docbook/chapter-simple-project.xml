<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="simple-project">
  <title>Ein einfaches Maven Projekt</title>

  <section id="simple-project-sect-intro">
    <title>Einleitung </title>

    <para>In diesem Kapitel führen wir ein einfaches Projekt ein, welches wir
    von Grund auf mit dem Maven Archetype Plugin erstellen. Diese Anwendung
    bietet uns die Gelegenheit einige grundlegende Konzepte von Maven
    einzuführen, während Sie einfach der Entwicklung des Projektes
    folgen.</para>

    <para>Sollten Sie bereits zuvor Maven eingesetzt haben, werden Sie
    festgestellt haben, dass Maven mit sehr wenigen Details gut zurecht kommt.
    Ihr Build wird "einfach funktionieren", und Sie brauchen sich nur um
    Details zu kümmern, wenn es notwendig ist, das Standardverhalten zu ändern
    oder ein angepasstes Plugin zu erstellen. Allerdings, sollten Sie
    gezwungen sein sich um die Details von Maven zu kümmern, so ist ein
    gutes Verständnis der grundlegenden Konzepte von wesentlicher
    Bedeutung. Dieses Kapitel zielt darauf ab, das einfachste mögliche
    Maven-Projekt einzuführen und daran Ihnen einige der grundlegenden
    Konzepte, welche die Maven zu einer soliden Build Plattform machen,
    vorzustellen. Nach dem Lesen dieses Kapitels werden Sie ein grundlegendes
    Verständnis des Build Lifecycles, des Maven Repositories, der
    Abhängigkeits-Verwaltung (Dependency Management) und dem Projekt Objekt
    Modell (POM) haben.</para>

    <section id="simple-project-sect-downloading-example">
      <title>Das Herunterladen der Beispiele dieses Kapitels </title>

      <para>Dieses Kapitel entwickelt ein sehr einfaches Beispiel, welches
      dazu dient einige Kern-Konzepte von Maven vorzustellen. Indem Sie den
      Schritten des Kapitels folgen, sollte es nicht notwendig werden die
      Beispiel herunterzuladen um den von Maven erstellten Quellcode einzusehen.
      Um dieses Beispiel zu erstellen werden wir das
      Archetype Maven Plugin einsetzen. Dieses Kapitel ändert das Projekt in
      keiner Weise. Sollten Sie es vorziehen, dieses Kapitel anhand der letzendlichen
      Quellcode-Beispiele zu lesen, so kann das Beispielprojekt dieses
      Kapitels zusammen mit den anderen Beispielen dieses Buchs von
      http://books.sonatype.com/maven-book/mvn-examples-1.0.zip oder
      http://books.sonatype.com/maven-book/mvn-examples-1.0.tar.gz
      heruntergeladen werden. Entpacken Sie das Archiv in ein beliebiges
      Verzeichnis, und gehen Sie dann zum Verzeichnis /ch03. Darin finden Sie
      ein Verzeichnis mit dem Namen /simple welches den Quellcode für dieses
      Kapitel enthält.</para>
    </section>
  </section>

  <section id="simple-project-sect-create-simple">
    <title>Erstellen eines einfachen Projekts</title>

    <para>Um ein neues Projekt unter Maven zu beginnen, setzen Sie das
    Archetype Maven-Plugin von der Befehlszeile aus ein.</para>

    <screen><command>$ mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 \
                                         -DartifactId=simple \
                                         -DpackageName=org.sonatype.mavenbook
</command>[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'archetype'.               
[INFO] artifact org.apache.maven.plugins:maven-archetype-plugin: checking for 
       updates from central
[INFO] -----------------------------------------------------------------------
[INFO] Building Maven Default Project
[INFO]    task-segment: [archetype:create] (aggregator-style)
[INFO] --------------------------------------------------------------------
[INFO] [archetype:create]
[INFO] artifact org.apache.maven.archetypes:maven-archetype-quickstart: \
       checking for updates from central
[INFO] Parameter: groupId, Value: org.sonatype.mavenbook.ch03
[INFO] Parameter: packageName, Value: org.sonatype.mavenbook
[INFO] Parameter: basedir, Value: /Users/tobrien/svnw/sonatype/examples
[INFO] Parameter: package, Value: org.sonatype.mavenbook
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] Parameter: artifactId, Value: simple
[INFO] * End of debug info from resources from generated POM *
[INFO] Archetype created in dir: /Users/tobrien/svnw/sonatype/examples/simple
</screen>

    <para><command>mvn</command> ist der Aufruf von Maven2; <command>archetype:create</command> bezeichnet ein Maven
    Goal. So Sie Ant kennen, ist ein Maven Goal gleichbedeutend mit einem Ant
    Target. Beide beschreiben eine Arbeitseinheit eines Builds. Die
    <command>-Dname=wert</command> Wertepaare stellen Argumente dar, welche an das Goal
    weitergereicht werden und nehmen die Form von <command>-D Eigenschaft</command> an, ähnlich
    deren welche Sie der Java Virtual Machine über die Befehlszeile
    weitergeben. Der Zweck des Goals <varname>archetype:create</varname> ist, schnell ein Projekt
    auf der Grundlage eines Archetypen zu erstellen. Ein Archetyp in diesem
    Kontext ist definiert als "ein originalgetreues Modell oder Typmuster nach
    dem andere, ähnliche Dinge gemustert sind, ein Prototyp" [1][2]. Von Maven
    werden etliche Archetypen bereitgehalten, diese reichen von der einfachen
    Swing Anwendung bis hin zur komplexen Web-Applikation. In diesem Kapitel
    werden wir den aller einfachsten Archtetypen nutzen um ein einfaches
    Gerüst eines Starter-Projekts zu erstellen. Das Plugin hat das Präfix
    "archetype" und das entsprechende Goal ist "create". Sobald wir das
    Projekt generiert haben, sehen Sie sich das Verzeichnis /simple und die
    von Maven darin generierte Verzeichnisstruktur näher an: </para>

    <screen>simple/<co id="coDef-simple-fs-root"
        linkends="coRef-simple-fs-root" />
simple/pom.xml<co id="coDef-simple-fs-pom" linkends="coRef-simple-fs-pom" />
      /src/
      /src/main/<co id="coDef-simple-fs-main" linkends="coRef-simple-fs-main" />
          /main/java
      /src/test/<co id="coDef-simple-fs-test" linkends="coRef-simple-fs-test" />
          /test/java</screen>

    <para>Der erzeugte Verzeichnisbaum hält sich an das Maven Standard Layout,
    wir werden später auf die Einzelheiten eingehen, aber für den Moment
    konzentrieren wir uns auf die wenigen grundsätzlichen
    Verzeichnisse:</para>

    <calloutlist>
      <callout arearefs="coDef-simple-fs-root" id="coRef-simple-fs-root">
        <para>Das Archetype Maven Plugin erstellt ein Verzeichnis, das mit der
        artifactId einhergeht: <filename>/simple</filename>. Dieses Verzeichnis ist bekannt als das
        Projekt Basis-Verzeichnis.</para>
      </callout>

      <callout arearefs="coDef-simple-fs-pom" id="coRef-simple-fs-pom">
        <para>Jedes Maven-Projekt benötigt was als als Projekt Objekt Modell
        (POM) bekannt ist, in einer Datei mit dem Namen <filename>pom.xml</filename>. Diese Datei
        beschreibt das Projekt, konfiguriert Plugins, und definiert
        Abhängigkeiten. </para>
      </callout>

      <callout arearefs="coDef-simple-fs-main" id="coRef-simple-fs-main">
        <para>Unser Projekt-Quellcode und zugehörige Ressourcen werden unter <filename>/src/main</filename>
        abgelegt. Im Falle unseres einfachen Java-Projekt wird dies aus ein
        paar Java-Klassen und einigen Property-Dateien bestehen. In einem
        anderen Projekt könnte dies das Root-Dokument einer Web-Anwendung
        sein, oder Konfigurationsdateien für einen Applikations-Server. In
        einem Java-Projekt werden die Java-Klassen in <filename>/src/main/java</filename> sowie
        Ressoucen in <filename>/src/main/resources</filename> abgelegt.</para>
      </callout>

      <callout arearefs="coDef-simple-fs-test" id="coRef-simple-fs-test">
        <para>Unsere Projekt-Testfälle befinden sich unter <filename>/src/test</filename>. In diesem
        Verzeichnis werden Java-Klassen wie z.B. JUnit oder TestNG Tests
        (<filename>/src/test/java</filename>) abgelegt, sowie Klassenpfad relevante
        Ressourcen für Tests unter <filename>/src/test/resources</filename>. </para>
      </callout>
    </calloutlist>

    <para>Das Maven Archetype Plugin erzeugt eine einzige Klasse
    <classname>com.sonatype.maven.App</classname>. Dies ist eine dreizeilige Java-Klasse mit einer
    statischen main()-Funktion welche eine Nachricht ausgibt: </para>

    <programlisting language="java">package org.sonatype.mavenbook;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
}
</programlisting>

    <para>Der einfachste Maven Archetyp generiert das einfachst mögliche
    Programm: ein Programm, welches "Hallo Welt!" auf der Standard-Ausgabe
    ausgibt. </para>
  </section>

  <section id="simple-project-sect-building-simple">
    <title>Der Aufbau eines einfachen Projekts </title>

    <para>Sobald Sie das Projekt mit dem Maven Archetype Plugin erstellt
    haben, indem Sie die Anweisungen aus Abschnitt 3.2: Erstellen eines
    einfachen Projekts ausführen, werden Sie es builden und als Anwendung
    paketieren wollen. Um dies zu bewerkstelligen, rufen Sie im Verzeichnis in
    welchem sich die pom.xml-Datei befindet den Befehl <command>mvn install</command> von der
    Befehlszeile auf. </para>

    <screen><command>$ mvn install
</command>[INFO] Scanning for projects...
[INFO] ----------------------------------------------------------------------
[INFO] Building simple
[INFO]    task-segment: [install]
[INFO] ----------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 1 source file to /simple/target/classes
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Compiling 1 source file to /simple/target/test-classes
[INFO] [surefire:test]
[INFO] Surefire report directory: /simple/target/surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running org.sonatype.mavenbook.AppTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.105 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] [jar:jar]
[INFO] Building jar: /simple/target/simple-1.0-SNAPSHOT.jar
[INFO] [install:install]
[INFO] Installing /simple/target/simple-1.0-SNAPSHOT.jar to \
  ~/.m2/repository/com/sonatype/maven/ch03/simple/1.0-SNAPSHOT/ \
  simple-1.0-SNAPSHOT.jar
</screen>

    <para>Sie haben soeben das einfachste mögliche Maven Projekt erstellt,
    kompiliert, getestet, paketiert und installiert. Um sich zu überzeugen,
    dass die Anwendung tatsächlich lauffähig ist, starten Sie sie von der
    Befehlszeile:</para>

    <screen><command>$ java -cp target/simple-1.0-SNAPSHOT.jar org.sonatype.mavenbook.App
</command>Hello World!
</screen>
  </section>

  <section id="simple-project-sect-pom">
    <title>Einfaches Projekt Objekt Modell (POM)</title>

    <para>Bei der Ausführung von Maven richtet dieses sich nach dem Projekt
    Objekt Modell (POM), um an Informationen über das Projekt zu gelangen. Das
    POM liefert Antworten auf Fragen wie: Welche Art von Projekte ist es? Wie
    lautet der Projektname? Gibt es irgendwelche Anpassungen am Build
    bezüglich diesem Projekt? Hier die grundlegende pom.xml-Datei wie sie vom
    Archetype Maven Plugin Goal create erstellt wurde. </para>

    <example id="example_simple-project-pom">
      <title>Einfachstes Projekt pom.xml Datei </title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.ch03&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
    </example>

    <para>Diese pom.xml-Datei stellt das elementarste POM dar mit welchem Sie
    je in einem Maven Projekt zu tun haben werden. In der Regel ist eine
    POM-Datei wesentlich komplexer: Abhängigkeiten werden definiert und Plugin
    Verhalten angepasst. Die ersten Elemente- <varname>groupId</varname>, <varname>artifactId</varname>, <varname>packaging</varname>
    sowie <varname>version</varname> sind als Maven-Koordinaten bekannt. Sie sind der eindeutigen
    Identifizierung eines Projekts gewidmet. <varname>name</varname> und <varname>url</varname> sind beschreibende
    Elemente des POM, welche in einer einfach lesbare Art den Namen des
    Projektes sowie einer zugeordneten Projekt-Website wiedergeben. Zuletzt
    wird im <varname>dependency</varname> Element eine einzige Beziehung als "Test-Scoped"
    Abhängigkeit zum JUnit-Test Framework unter dem Namen JUnit definiert.
    Diese Themen werden im Abschnitt 3.5: "Kernkonzepte" ausgeführt. Zum
    jetzigen Zeitpunkt ist alles was sie wissen müssen, dass die pom.xml-Datei
    Maven zum Leben erweckt. </para>

    <para>Bei der Ausführung von Maven wird dieses gesteuert durch eine
    Kombination von Einstellungen innerhalb der pom.xml-Datei, einer Art
    "Super"-POM welche sich im Installationsverzeichnis von Maven befindet,
    sowie (möglicherweise) einigen benutzerspezifischen Einstellungen. Um
    sich das "tatsächliche" POM, oder das POM, gegen welches Maven ausgeführt
    wird anzusehen, geben Sie im Stammverzeichnis Ihres Projekts den folgenden
    Befehl ein:</para>

    <screen>$ <command>mvn help:effective-pom</command></screen>

    <para>Mit der Ausführung bekommen Sie ein wesentlich umfangreicheres POM,
    das auch die Maven Standardeinstellungen enthält</para>
  </section>

  <section id="simple-project-sect-simple-core">
    <title>Kern Konzepte </title>

    <para>Nachdem Sie nun zum ersten Mal Maven eingesetzt haben, ist ein guter
    Zeitpunkt gekommen einige der Kernkonzepte von Maven einzuführen. Im vorigen
    Beispiel haben Sie, aufbauend auf ein einfaches POM, ein einfaches Projekt
    generiert, welches im Standard Layout von Maven (der Konvention folgend)
    strukturiert die Quelldateien abgelegt hat. Sie haben dann Maven mit einer
    Lebenszyklusphase als Argument aufgerufen und damit ausgelöst, dass Maven
    eine Anzahl Plugin Goals abgearbeitet hat. Zuletzt haben Sie einen Maven
    Artifact in Ihr lokales Repository installiert. Moment! Was ist ein
    "Lebenszyklus"? Was ist ein "lokales Repository"? Die folgenden Abschnitte
    beschreiben einige der für Maven zentralen Konzepte.</para>

    <section id="simple-project-sect-plugins-goals">
      <title>Maven Plugins und Ziele </title>

      <para>Im vorigen Abschnitt haben wir Maven mit zwei unterschiedlichen
      Kommandozeilen-Argumenten aufgerufen. Der erste Befehl war ein einziges
      Plugin Goal, das Goal create des Archetype Maven Plugin. Der zweite
      Aufruf von Maven war hingegen gekoppelt mit einer Lifecycle-Phase -
      install. Um ein einzelnes (bestimmtes) Maven Plugin Goal auszuführen,
      benutzten wir die Syntax <command>mvn archetype:create</command>, hierbei ist <varname>archetype</varname> die
      Kennung eines Plugins und <varname>create</varname> die Kennung eines Goals. Wann immer
      Maven ein Plugin Goal ausführt, gibt es die Plugin- sowie die
      Goal-Kennung auf der Standardausgabe aus:</para>

      <screen><command>$ mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 \
                                        -DartifactId=simple \
                                        -DpackageName=org.sonatype.mavenbook
</command>...
<emphasis>[INFO] [archetype:create]</emphasis>
[INFO] artifact org.apache.maven.archetypes:maven-archetype-quickstart: \
       checking for updates from central
...
</screen>

      <para>Ein Maven-Plugin ist eine Sammlung von einem oder mehreren Goals.
      Beispiele von Maven-Plugins sind einfache Core-Plugins wie das
      JAR-Plugin welches das Goal zur Erzeugung von JAR-Archiven beinhaltet;
      das Compiler-Plugin mit den Goals Source Code kompilieren oder Unit Test
      Quellcode zu kompilieren oder das Surefire Plugin welches Goals zum
      Abarbeiten von Unit Tests sowie der Report Generierung diesbezüglich
      beinhaltet. Andere, stärker spezialisierte Maven-Plugins sind z. B. das
      Hibernate3 Plugin zur Integration mit der beliebten Hibernate Persistenz
      Bibliothek, dem JRuby Plugin, welches erlaubt Ruby als Teil des Builds
      auszuführen sowie Maven Plugins in Ruby zu schreiben. Maven sieht auch
      vor benutzerdefinierte Plugins einzubinden. Ein benutzerdefiniertes
      Plugin kann in Java geschrieben sein, oder aber auch in einer von vielen
      anderen Sprachen darunter Ant, Groovy, BeanShell, und, wie bereits
      erwähnt, Ruby.</para>

      <figure>
        <title>Ein Plugin enthält Goals </title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/simple-project_plugin.png"
                       width="5in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Ein Goal ist eine spezifische Aufgabe, welche alleinstehend, oder
      zusammen mit anderen Goals als Teil eines größeren Builds ausgeführt
      werden kann. Ein Goal ist eine "Arbeitseinheit" in Maven. Beispiele von
      Goals sind das Goal compile des Compiler-Plugin, es kompiliert den
      gesamten Quellcode für ein Projekt, oder das Goal test des Surefire
      Plugin welches Unit-Tests ausführen kann. Goals werden durch
      Konfigurations-Parameter bestimmt, welche erlauben das Verhalten
      anzupassen. Ein Beispiel, das Goal compile des Compiler-Plugin definiert
      eine Reihe von Konfigurations-Parameter, mit denen Sie die gewünschte
      JDK-Version Version bestimmen, sowie über den Einsatz von
      Compiler-Optimierungen bestimmen können. Im vorigen Beispiel haben wir über die
      Befehlszeile die Parameter <varname>groupId</varname> und <varname>artifactId</varname> an das Goal create des
      Archetype Plugin weitergegeben (<classname>-DgroupId=com.sonatype.maven.ch03</classname> sowie
      <classname>-DartifactId=simple</classname>). Darüber hinaus haben wir den Parameter <varname>packageName</varname>
      als <classname>com.sonatype.maven</classname> an das Goal create weitergegeben. Hätten wir den
      Parameter packageName ausgelassen, wäre die Voreinstellung
      <classname>com.sonatype.maven.ch03</classname> zum Zug gekommen. </para>

      <para><note>
          <para>Im weiteren Text werden wir häufig, wenn wir auf ein Plugin
          Goal verweisen eine verkürzte Notation benutzen: <varname>pluginId:goalId</varname>;
          Ein Beispiel: um sich auf das Goal create des Archetype Maven Plugin
          zu beziehen schreiben wir <varname>archetype:create</varname>. </para>
        </note></para>

      <para>Goals legen Parameter fest, für welche vernünftige Standardwerte
      definiert sein können. Im vorangehenden Beispiel <varname>archtetype:create</varname>,
      wurde der Archetype nicht spezifiziert, es wurde lediglich eine <varname>groupId</varname>
      sowie eine <varname>artifactId</varname> weitergegeben. Hier kommen wir das erste mal mit
      Konvention vor Konfiguration in Berührung. Die Konvention, oder
      der Standard, des Goals create ist die Generierung eines einfachen Projektes
      namens Quickstart. Das Goal create definiert einen Parameter
      <varname>archetype:artifactId</varname> welcher auf den Standardwert
      <varname>maven-archetype-quickstart</varname> gesetzt ist. Der Archetyp 'Quickstart'
      erzeugt eine minimale Projekthülse, mit zugehörigem POM sowie einer
      einzigen Klasse. Das Archetype Plugin ist wesentlich mächtiger als
      dieses Beispiel andeutet, jedoch ist es eine gute Möglichkeit, um neue
      Projekte schnell zu starten. Später in diesem Buch, zeigen wir Ihnen,
      wie das Archetype Plugin benutzt werden kann, um komplexere Projekte wie
      Web-Anwendungen zu generieren, und wie Sie das Archetype Plugin benutzen
      können um Ihren eigenen Satz von Projekten zu definieren.</para>

      <para>Der Kern von Maven hat nur wenig zu tun mit den spezifischen
      Aufgaben welche am Build Ihres Projektes beteiligt sind. Von sich aus
      weiss Maven nicht wie man Ihre Quelldateien kompiliert oder gar ein
      JAR-Archive packt. Maven delegiert all diese Arbeiten an Maven-Plugins
      wie das Compiler Plugin oder das JAR-Plugin. Diese können, sobald sie
      gebraucht werden, aus dem zentralen Maven Repository heruntergeladen und
      periodisch aktualisiert werden. Wenn Sie Maven herunterladen, so
      bekommen Sie lediglich den Kern oder Core von Maven. Dieser besteht aus einer sehr
      grundlegenden Shell, welche nur in der Lage ist die Befehlszeile zu
      analysieren, den Klassenpfad zu verwalten, eine POM-Datei zu analysieren
      und nach Bedarf Plugins herunterzuladen. Indem das Compiler Plugin vom
      Core getrennt gehalten wurde und über einen Update Mechanismus verfügt,
      ist es ein Leichtes für den Benutzer, auch die neusten Compiler Optionen
      zum Einsatz zu bringen. Auf diese Weise ermöglichen Maven-Plugins
      universelle Wiederverwendbarkeit von übergreifender Buildlogik, Sie
      definieren nicht einen Kompilierungs-Task innerhalb des Builds, Sie
      benutzen das Compiler Plugin wie es von jedem Maven Benutzer eingesetzt
      wird. Wird das Plugin weiterentwickelt, kann jedes Projekt auf der Basis
      von Maven sofort den Nutzen daraus ziehen (und sollten Sie das Compiler
      Plugin nicht mögen, so können Sie es übersteuern und Ihr eigenes zum
      Einsatz bringen!).</para>
    </section>

    <section id="simple-project-sect-lifecycle">
      <title>Maven Lifecycle</title>

      <para>Der zweite Aufruf des vorangegangenen Abschnitts war <command>mvn package</command>.
      Bei diesem Aufruf wurde kein Plugin Goal angegeben, statt dessen wurde
      eine Lebenszyklusphase angegeben. Eine Phase ist ein Schritt in dem was
      Maven den "Build Lifecycle" nennt. Der Build Lebenszyklus ist eine
      geordnete Folge von Phasen welche am Aufbau eines Projekts beteiligt
      sind. Maven unterstützen kann eine Reihe ganz unterschiedlicher
      Lebenszyklen. Der am häufigsten zum Einsatz kommende ist der
      Standard-Lebenszyklus. Dieser beginnt mit eine Phase der Validierung der
      grundlegenden Integrität des Projekts und endet mit einer Phase der
      Bereitstellung von einem Projekt für die Produktion. Lifecycle Phasen
      sind bewusst vage gehalten, im einzelnen lediglich definiert als
      Validierung, Test oder Verteilung kann eine Phase für verschiedene
      Projekte ganz unterschiedliche Bedeutung haben. Zur Verdeutlichung ein
      Beispiel: die Phase package bedeutet in einem Projekt welches ein
      JAR-Archive erstellt: 'erstelle ein JAR-Archive', hingegen in einem
      Projekt welches eine Webanwendung zum Ziel hat: 'Erstelle ein
      WAR-Archive'. Abbildung 3.2 "Ein Lebenszyklus besteht aus einer Abfolge
      von Phasen" zeigt eine vereinfachte Darstellung des Maven Standard
      Lebenszykluses. </para>

      <para>Plugin-Goals können an Lebenszyklus-Phasen gebunden werden. Mit
      dem Durchschreiten des Lebenszykluses arbeitet Maven die Goals der
      einzelnen Phasen ab. An jeder Phase können keine (0) oder mehrere Goals
      gebunden sein. Im vorangegangenen Abschnitt, beim Aufruf von <command>mvn
      package</command>, haben Sie vielleicht bemerkt, dass mehr als ein Ziel ausgeführt
      wurde. Sehen Sie sich die Ausgabe nach dem Ausführen von <command>mvn package</command>
      genau an, Sie werden sehen, dass verschiedene Goals ausgeführt wurden.
      Als dieses einfache Beispiel die Phase package erreichte, führte es das
      Goal jar des Jar Plugins aus. Da unser einfaches Schnellstart-Projekt
      (standardmäßig) den Paketierungstyp jar setzt, wird das Goal jar:jar an
      die Phase package gebunden. </para>

      <para><figure>
          <title>Ein Goal wird an eine Phase gebunden </title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/simple-project_phasebinding.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Wir wissen nun, dass die Phase package für ein Projekt mit
      jar-Paketierung ein JAR-Archive erstellen wird. Aber wie steht es um die
      vorangehenden Goals, deren wie etwa <varname>compiler:compile</varname> und <varname>surefire:test</varname>?
      Diese Goals werden von Maven beim Durchschreiten der vorhergehenden
      Phasen des Lebenszykluses abgearbeitet. Der Aufruf einer bestimmten
      Phase löst aus, dass alle vorgängigen Phasen in entsprechender
      Reihenfolge abgearbeitet werden. Mit dem Abschluss der spezifizierten
      Phase endet die Bearbeitung. Jede Phase entspricht keinem oder mehreren
      abzuarbeitenden Goals, und da wir keine weitere Plugin-Konfiguration
      oder Anpassung durchgeführt haben, bindet dieses Beispiel lediglich eine
      Reihe von Standard-Plugin-Goals an den Standard-Lebenszyklus. Läuft
      Maven entlang des definierten Standard-Lebenszykluses bis zur Phase
      package, werden die folgenden Goals in der angegebenen Reihenfolge
      ausgeführt: </para>

      <variablelist>
        <varlistentry>
          <term><varname>resources:resources</varname></term>

          <listitem>
            <para>Das Goal resources des Resouces Plugin wird an die Phase
            resources gebunden. Dieses Goal kopiert alle Ressourcen von
            <filename>/src/main/resources</filename> und allen anderen, konfigurierten Ressource-
            Verzeichnissen in das Ausgabe-Verzeichnis. </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>compiler:compile</varname></term>

          <listitem>
            <para>Das Goal compile des Compiler Plugin wird an die Phase
            compile gebunden. Dieses Ziel kompiliert den gesamten Quellcode
            von <filename>/src/main/java</filename> oder jedem anderen konfigurierten
            Quellen-Verzeichnisse in das Ausgabe-Verzeichnis. </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>resources:testResources</varname></term>

          <listitem>
            <para>Das Goal testResources des Resources Plugin wird an die
            Phase test-resources gebunden. Dieses Goal kopiert alle Ressourcen
            von <filename>/src/test/resources</filename> und jedem anderen, konfigurierten
            Test-Ressource Verzeichnis in ein Test Ausgabe Verzeichnis.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>compiler:testCompile</varname></term>

          <listitem>
            <para>Das Goal testCompile des Compiler-Plugin wird an die Phase
            test-compile gebunden. Dieses Goal kompiliert die Testfälle von
            <filename>/src/test/java</filename> und allen anderen konfigurierten
            Test-Quellen-Verzeichnissen in ein Test Ausgabe
            Verzeichnis.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>surefire:test</varname></term>

          <listitem>
            <para>Das Goal test des Surefire Plugin wird an die Phase test
            gebunden. Dieses Ziel führt alle Tests aus und generiert
            Ausgabedateien der detaillierten Ergebnissen. Standardmäßig wird
            dieses Goal den Build beenden, sollte ein Test scheitern.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>jar:jar</varname></term>

          <listitem>
            <para>Das Goal jar des JAR-Plugin wird an die Phase package
            gebunden. Dieses Goal paketiert das Ausgabeverzeichnis und
            erstellt ein JAR-Archiv. </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para><figure>
          <title>Gebundene Goals werden mit den zugehörigen Phasen ausgeführt.
          (Anmerkung: Es bestehen mehr Phasen als oben abgebildet, dies ist
          ein Auszug der Möglichkeiten) </title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/simple-project_lifecyclebinding.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Wir fassen zusammen: beim Ausführen von <command>mvn package</command> durchläuft
      Maven alle Lebenszyklus Phasen bis und mit <varname>package</varname>, und führt hierbei in
      Abfolge alle Goals aus, welche zugehörig an Phasen gebunden sind.
      Anstelle der Angabe eines Maven Lifecycle Goals, können Sie das gleiche
      Ergebnis erreichen, indem Sie eine Abfolge von Plugin Goals
      angeben:</para>

      <screen><command>mvn resources:resources \
    compiler:compile \
    resources:testResources \
    compiler:testCompile \
    surefire:test \
    jar:jar \
    install:install</command> 
</screen>

      <para>Die Ausführung der Phase package ist der Verwaltung aller
      beteiligten Goals eines bestimmten Builds vorzuziehen. Ein derartiges
      Vorgehen erlaubt den Projekten auch die Einhaltung genau definierter
      Standards. Es ist der Lebenszyklus, welcher einem Entwickler erlaubt von
      von einem Maven-Projekt zu einem anderen zu springen, ohne sich um die
      Details der einzelnen Builds zu kümmern. Schaffen Sie es ein
      Maven-Projekt zu builden, so schaffen Sie dies für alle!</para>
    </section>

    <section id="simple-project-sect-maven-coordinates">
      <title>Maven Koordinaten</title>

      <para>Das Archetype Plugin erstellte ein Projekt mit einer Datei namens
      pom.xml. Dies ist das Projekt Objekt Modell (POM), eine deklarative
      Beschreibung eines Projekts. Wenn Maven ein Goal ausführt hat jedes Goal
      Zugang zu den im Projekt POM definierten Informationen. Wenn das Goal
      jar:jar ein JAR-Archive erstellen soll, sieht es in der POM Datei nach
      um herauszufinden wie das JAR-Archive heissen soll. Soll das Goal
      compiler:compiler Java Quelldateien kompilieren greift das Goal auf die
      POM Dateien zurück, um zu sehen ob dort Compiler Eigenschaften definiert
      sind. Goals werden immer im Kontext eines POMs ausgeführt. Goals sind
      Aktionen welche wir auf ein Projekt anwenden möchten, und Projekte sind
      in POM Dateien abgebildet. Das POM bezeichnet ein Projekt, stellt einen
      Satz von Identifikationsmerkmale (Koordinaten) für ein Projekt, und
      definiert die Beziehungen zwischen diesem Projekt und andern Projekten
      durch die Angabe von Abhängigkeiten, Eltern und Voraussetzungen. Ein POM
      kann auch Plugin-Verhalten beeinflussen sowie Informationen über die
      Entwicklergemeinde und an einem Projekt beteiligten Entwicklern
      bereitstellen. </para>

      <para>Maven Koordinaten stellen eine Anzahl Identifikatoren, welche zur
      eindeutigen Identifikation eines Projekts, einer Abhängigkeit oder eines
      Maven Plugins genutzt werden können. Werfen Sie einen Blick auf das
      folgende POM.</para>

      <para><figure>
          <title>Maven Projekt Koordinaten</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/simple-project_annopom.png"
                         width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Wir haben die Maven Koordinaten für dieses Projekt: <varname>groupId</varname>,
      <varname>artifactId</varname>, <varname>version</varname> und <varname>packaging</varname> vorgestellt.
      Die Einheit dieser
      Identifikatoren bildet die Koordinaten eines Projekts[3]. Genau wie in
      jedem anderen Koordinatensystem, fixieren diese Koordinaten einen
      bestimmten Punkt im Raum: vom Allgemeinen zum Spezifischen. Maven
      bestimmt ein Projekt mit dessen Koordinaten, so sich ein Projekt auf ein
      anderes bezieht, entweder als Abhängigkeit, Plugin oder auch elterliche
      Projekt Referenz. Maven Koordinaten werden gewöhnlich durch einen
      Doppelpunkt getrennt in folgender Form wiedergegeben:
      <varname>groupId:artifactId:version:packaging</varname>. Die Koordinate des im obigen
      Beispiel einer pom.xml-Datei eines Projektes sind daher folgendermassen
      wiedergegeben: <varname>mavenbook:my-app:jar:1.0-SNAPSHOT</varname>. Diese Notation gilt
      auch für Projekt-Abhängigkeiten; unser Projekt basiert auf JUnit Version
      3.8.1, es enthält daher eine Abhängigkeit zu <varname>junit:junit:jar:3.8.1</varname> .
      <footnote id="foot-simple-classify">
          <para>Es gibt eine weitere, fünfte Koordinate: <varname>classifier</varname>. Diese
          kommt nur selten zum Einsatz und wir werden die Einführung daher auf
          später im Buch zurückstellen. Nehmen Sie sich die Freiheit diese
          Koordinate im Moment zu ignorieren. </para>
        </footnote></para>

      <variablelist>
        <varlistentry>
          <term><varname>groupId</varname></term>

          <listitem>
            <para>Die "Gruppe" (Firma, Team, Organisation, Projekt, oder
            anderweitige Gruppe). Es gilt die ungeschriebene Regel, dass die
            <varname>groupId</varname> in der Reverse-Domain-Name Notation der Organisation
            die das Projekt erstellt, wiedergegeben wird. Projekte von Sonatype
            hätte eine <varname>groupId</varname> welche mit <varname>com.sonatype</varname> beginnt, Projekte der
            Apache Software Foundation hätte eine <varname>groupId</varname> welche mit
            <varname>org.apache</varname> beginnt. </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>artifactId</varname></term>

          <listitem>
            <para>Eine eindeutige hierarchische Kennung unter der <varname>groupId</varname>,
            identifiziert ein einzelnes Projekt. </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>version</varname></term>

          <listitem>
            <para>Eine bestimmte Version eines Projekts. Freigegebene Projekte
            haben eine bestimmte, festgelegte Versionskennung. Diese bezieht
            sich immer auf genau eine Version des Projekts. Projekte in der
            aktiven Entwicklung können eine spezielle Kennung bekommen, diese
            markiert die angegebene Version als eine "Momentaufnahme".</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Der Identifikator <varname>packaging</varname> ist ebenfalls ein wichtiger
      Bestandteil der Maven Koordinaten, aber nicht Teil der eindeutigen
      Projektkennung. Eine Projektdarstellung der Art
      <varname>groupId:artifactId:version</varname> bezeichnet ein Projekt einzigartig
      (kanonisch). Es ist nicht möglich ein weiteres Projekt mit dem gleichen
      Bezeichnern zu erstellen.</para>

      <variablelist>
        <varlistentry>
          <term><varname>packaging</varname></term>

          <listitem>
            <para>Die Art in welcher das Projekt 'gepackt' ist, dies ist auf den
            Standardwert 'jar' gesetzt. Ein Projekt vom Packaging Typ 'jar'
            wird als JAR-Archive bereitgestellt, eines des Types 'war' in Form
            eines WAR-Archives.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Diese vier Elemente bestimmen den Schlüssel um ein Projekt
      eindeutig im weiten Raum "mavenisierter" Projekte aufzufinden.
      Maven-Repositories (öffentliche, private und lokale) sind nach diesen
      Identifikatoren organisiert. Sobald ein Projekt im lokalen
      Maven-Repository eingestellt ist, steht es augenblicklich für alle
      weiteren Projekte (welche gegen dieses Repository arbeiten) bereit, eingebunden zu werden. Alles was zu tun bleibt,
      ist die Koordinaten in einem anderen Projekt als Abhängigkeit
      einzutragen.</para>

      <para><figure>
          <title>Der 'Maven'-Raum stellt ein Koordinatensystem für Projekte
          </title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/simple-project_mavenspace.png"
                         width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </section>

    <section id="simple-project-section-simple-repo">
      <title>Maven Repositories</title>

      <para>Beim ersten Ausführen von Maven, werden Sie feststellen, dass
      Maven eine Reihe von Dateien von einem Maven Remote Repository
      herunterlädt. Sollte die Erstellung des einführenden Projektes das erste
      Mal sein, dass Sie Maven aufrufen, so ist das erste was passiert, dass
      Maven die neuste Version des Resource Plugins herunterlädt, ausgelöst
      durch das Goal <varname>resources:resource</varname>. Maven lädt Artefakte und Plugins aus
      einem Remote Repository sobald diese benötigt werden. Einer der Gründe,
      weshalb der Maven Download ist so klein ist (1,5 MiB) ist, dass Maven
      nicht mit allerlei Plugins ausgeliefert wird. Ausgeliefert wird nur das
      Allernötigste, alles weitere holt sich Maven bei Bedarf aus einem
      Remote-Repository. Maven kommt hierzu mit einer Standardeinstellung
      eines Remote Repositories (http://repo1.maven.org/maven2) von welchem es versuchen wird
      die Core Maven-Plugins und deren Abhängigkeiten herunterzuladen. </para>

      <para>Oftmals werden Sie an einem Projekt arbeiten, welches auf
      Bibliotheken aufbaut, welche weder frei noch öffentlich zu verbreiten
      sind. In einem solchen Fall müssen Sie entweder ein benutzerdefiniertes
      Repository innerhalb Ihrer Organisation aufbauen oder die Abhängigkeiten
      manuell herunterladen und installieren. Die Standard (Remote)
      Repositorien können durch Verweise auf benutzerdefinierte Maven
      Repositorien ersetzt oder ergänzt werden. Es gibt eine Reihe Produkte
      welche Organisationen dabei unterstützen eigene Repositorien zu
      verwalten sowie Spiegel-Repositorien von öffentlichen Maven-Repositorien
      zu erstellen.</para>

      <para>Was macht ein Maven Repository zu einem Maven Repository? Ein 
      Maven-Repository zeichnet sich durch seine Struktur aus, ein Repository
      ist eine Sammlung von Projekt Artefakten in einer Struktur und Form
      welche für Maven leicht leicht nachvollziehbar ist. Die Artefakte in
      einem Maven-Repository sind in einer Verzeichnis-Struktur abgelegt, welche
      eng mit den Maven Projekt Koordinaten korrespondieren. Sie können sich
      diese Struktur ansehen: öffnen Sie mit einem Web-Browser das zentrale
      Maven Repository auf http://repo1.maven.org/maven2/. Sie können dort ein
      Artefakt mit den Koordinaten <varname>org.apache.commons:commons-email:1.1</varname> im
      Verzeichnis <filename>/org/apache/commons/commons-email/1.1/</filename> in einer Datei namens
      "<filename>commons-email.jar</filename>" vorfinden. Der Standard für ein Maven-Repository ist
      es, einen Artefakten in folgender Struktur relativ zum Wurzelverzeichnis
      des Repositories abzulegen:<screen>/&lt;<varname>groupId</varname>&gt;/&lt;
      <varname>artifactId</varname>&gt;/&lt;<varname>version</varname>&gt;/&lt;
      <varname>artifactId</varname>&gt;-&lt;version&gt;.&lt;<varname>packaging</varname>&gt;
      </screen></para>

      <para>Maven lädt Artefakte und Plugins von einem Remote-Repository auf
      Ihren lokalen Rechner herunter und speichert diese Artefakte in Ihrem
      lokalen Maven-Repository. Ist ein Artefakt einmal von einem Remote Repository
      in das lokale Repository heruntergeladen, so wird Maven kein weiteres
      mal auf das Remote Repository zugreifen, da Maven immer zuerst auf das
      lokale Repository zugreifen wird, vor es anderswo sucht. Unter Windows XP
      befindet sich Ihr lokales Repository wahrscheinlich unter <filename>C:\Dokumente
      und Einstellungen\Benutzername\.m2\Repository</filename>, unter Windows Vista
      befindet sich Ihr lokales Repository unter
      <filename>C:\Benutzer\Benutzername\.m2\Repository</filename> auf Unix-Systemen werden Sie
      Ihr lokales Maven-Repository unter <filename>~/.m2/repository</filename> wiederfinden.
      Sobald Sie ein Projekt wie das aus dem vorherigen Abschnitt erstellen, wird
      in der Phase install ein Goal ausgeführt welches den neuen Artifakten
      in Ihrem lokalen Maven Repository ablegt. </para>

      <para>Sie sollten nun in der Lage sein, das Artefakt Ihres eingängigen
      Projektes in Ihrem lokalen Maven Repository wiederzufinden. Beim Aufruf
      von <command>mvn install</command> installiert Maven den Projekt Artefakt in Ihrem lokalen
      Repository. Probieren Sie es aus. </para>

      <screen>$ <command>mvn install</command>
...
[INFO] [install:install]
[INFO] Installing .../simple-1.0-SNAPSHOT.jar to \
       ~/.m2/repository/com/sonatype/maven/simple/1.0-SNAPSHOT/ \
       simple-1.0-SNAPSHOT.jar
...</screen>

      <para>Betrachten Sie die Ausgabe dieses Befehls, Sie können sehen, wie
      Maven unseres Projekt's JAR-Archiv im lokalen Maven-Repository ablegt.
      Maven nutzt das lokale Repository um Artefakte zwischen lokalen Projekten
      zu teilen. Sagen wir, Sie entwickeln zwei Projekte, Projekt A und
      Projekt B, dabei ist Projekt B von einem Artefakt von Maven-Projekt A
      abhängig. So wird Maven den Artefakt beim Build von Projekt B aus Ihrem
      lokalen Repository holen. Maven Repositorien sind beides, ein lokaler
      Zwischenspeicher (Cache) von Artefakten welche von einem Remote
      Repository heruntergeladen wurden, wie auch ein Mechanismus welcher
      erlaubt, dass Ihre Projekte zueinander abhängig sein können.</para>
    </section>

    <section id="simple-project-sect-dep-management">
      <title>Maven Abhängigkeits-Management (Dependency Management)</title>

      <para>In dem einfachen Beispiel dieses Kapitels, löst Maven die
      Koordinaten der JUnit-Abhängigkeit <varname>junit:junit:3.8.1</varname> in einen Pfad
      <filename>/junit/junit/3.8.1/junit-3.8.1.jar</filename> des Maven Repositories auf. Die
      Möglichkeit, Artefakte in einem Repository basierend auf Maven
      Koordinaten zu lokalisieren gibt uns die Möglichkeit Abhängigkeiten in
      einem Projekt POM zu definieren. Sehen Sie sich die <filename>pom.xml</filename>-Datei
      genauer an. Sie werden einen Abschnitt finden, welcher sich mit den
      Abhängigkeiten (dependencies) befasst, dieser Abschnitt enthält eine
      einzige Abhängigkeit: <classname>JUnit</classname>. </para>

      <para>Ein komplexeres Projekt würde mehr als eine einzelne Abhängigkeit
      beinhalten, oder auch Abhängigkeiten welche von anderen Artefakten
      abhängen. Dies ist eine der mächtigsten Funktionen von Maven: die
      Unterstützung von transitiven Abhängigkeiten. Nehmen wir an, Ihr Projekt
      hängt von einer Bibliothek ab, welche wiederum von fünf oder zehn
      anderen Bibliotheken abhängig ist (etwa wie Spring oder Hibernate).
      Statt alle diese Abhängigkeiten nachzuverfolgen und in Ihrem pom.xml
      explizit aufzulisten können Sie schlicht diejenige Abhängigkeit
      aufnehmen, welche Sie beabsichtigen. Maven wird die implizit abhängigen
      Bibliotheken für Sie auflösen. Maven wird auch auftretende Konflikte
      auflösen, diesbezüglich bietet Maven die Möglichkeit das Verhalten
      anzupassen sowie gewisse transitive Abhängigkeiten
      auszuschliessen.</para>

      <para>Werfen wir einen Blick auf eine Abhängigkeit, welche im
      vorangegangenen Beispiel in Ihr lokales Repository heruntergeladen
      wurde. Sehen Sie in Ihrem lokalen Repository-Pfad unter
      <filename>~/.m2/repository/junit/junit/3.8.1/</filename> nach. Wie Ihnen nach der Lektüre
      des Kapitels bekannt ist, gibt es eine Datei <filename>junit-3.8.1.jar</filename> sowie eine
      <filename>junit-3.8.1.pom</filename>-Datei und zusätzlich eine Anzahl Dateien; Prüfsummen welche
      Maven nutzt, um die Echtheit eines heruntergeladenen Artefakts zu
      überprüfen. Beachten Sie, dass Maven nicht nur das JUnit JAR-Archive
      herunterlädt. Maven lädt zusätzlich das POM des Artefakts herunter. Die
      Tatsache, dass Maven zusätzlich zum Artefakt auch die zugehörige POM
      Dateien herunterlädt ist von zentraler Bedeutung für die Unterstützung
      von transitiven Abhängigkeiten durch Maven.</para>

      <para>Sie werden feststellen, dass Maven bei der Installation Ihres
      Projekt-Artefaktes in das lokale Maven-Repository zugleich eine leicht
      modifizierte Version der zugehörigen pom.xml-Datei im selben Verzeichnis
      des JAR-Archives ablegt. Zugleich eine POM-Datei im Repository abzulegen
      gibt anderen Projekten Informationen zu diesem Projekt, als Wichtigstes
      dessen Abhängigkeiten. Projekt B, abhängig von Projekt A, hängt auch von
      den Abhängigkeiten des Projekts A ab. Wenn Maven eine Abhängigkeit zu
      einem Artefakt anhand einer Reihe von Artefaktkoordinaten auflöst, so
      ruft Maven die POM-Dateien auf und nimmt sich deren Abhängigkeiten an,
      um bestehende transitive Abhängigkeiten aufzulösen. Jene transitiven
      Abhängigkeiten werden sodann den Projektabhängigkeiten zugefügt.</para>

      <para>Eine Abhängigkeit in Maven ist nicht nur eben ein JAR-Archiv. Es
      ist eine POM-Datei, welche weitere Abhängigkeiten von anderen Artefakten
      erklären kann. Solche Abhängigkeiten der Abhängigkeiten nennt man
      transitive Abhängigkeiten und sie werden durch die Tatsache, dass das
      Maven-Repository mehr als nur den Bytecode speichert ermöglicht. Maven
      speichert Meta-Daten bezüglich der Artefakte. Die folgende Abbildung
      zeigt ein mögliches Szenario transitiver Abhängigkeiten.</para>

      <figure>
        <title>Wie Maven transitive Abhängigkeiten auflöst / Resolving
        transitive Dependencies </title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/simple-project_depgraph.png"
                       width="6in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In der vorangegangenen Abbildung, ist ein Projekt abhängig von den
      Projekten B und C. Projekt B baut auf Projekt D auf, Projekt C baut auf
      Projekt E auf. Die Gesamtmenge aller Abhängigkeiten von A sind Projekte
      B, C, D, E, jedoch musste Projekt A lediglich die Projekte B und C
      deklarieren. Transitive Abhängigkeiten können sich immer dann als
      nützlich erweisen, wenn Ihr Projekt sich auf ein anderes Projekt
      abstützt, welches weitere Abhängigkeiten deklariert (z.B. Hibernate,
      Apache Struts, oder das Spring Framework). Maven bietet Ihnen auch die
      Möglichkeit, transitive Abhängigkeiten von der Aufnahme in den
      Klassenpfad auszuschliessen.</para>

      <para>Maven kennt auch das Konzept des Gültigkeitsbereichs (Scope). Die
      <filename>pom.xml</filename>-Datei des Beispielprojektes kennt nur eine einzige Abhängigkeit
      <varname>junit:junit:jar:3.8.1</varname> in einem Gültigkeitsbereich <varname>test</varname>. Wenn eine
      Abhängigkeit bezüglich eines Gültigkeitsbereich <varname>test</varname> definiert ist, so
      bedeutet dies, dass diese nicht dem Goal compile des Compiler Plugins
      zur Verfügung steht. Die Abhängigkeit wird dem Klassenpfad nur für die
      Goals compiler:testCompile sowie surefire:test zugefügt.</para>

      <para>Bei der Erstellung eines JAR-Archivs für ein Projekt werden
      Abhängigkeiten nicht mit eingeschlossen, es wird lediglich gegen diese
      kompiliert. Beim Erstellen eines WAR- oder EAR-Archives können Sie
      konfigurieren, ob Sie Abhängigkeiten in den erstellten Artefakt
      einschliessen möchten. Ebenfalls möglich ist der Ausschluss bestimmter
      Abhängigkeiten abhängig vom gewählten Gültigkeitsbereich. Der
      Gültigkeitsbereich <varname>provided</varname> bestimmt, dass die Abhängigkeit benötigt
      wird um zu kompilieren, aber nicht in den Erstellten Artefakt
      eingebunden werden soll. Dieser Gültigkeitsbereich (<varname>provided</varname>) ist
      nützlich, wenn Sie eine Web Applikation erstellen; Sie müssen z.B. gegen die
      Servlet Spezifikation kompilieren, jedoch werden Sie vermeiden, das
      Servlet API JAR-Archiv in das <filename>/WEB-INF/lib</filename> Verzeichnis Ihrer
      Webanwendung abzulegen. </para>
    </section>

    <section id="simple-project-sect-site-generation">
      <title>Site-Generierung und Reporting </title>

      <para>Eine weitere wichtige Möglichkeit ist die Fähigkeit von Maven
      Dokumentationen und Reports zu Generieren. Führen Sie im
      Stammverzeichnis der Beispielanwendung folgenden Aufruf aus:</para>

      <screen>$ <command>mvn site</command>
</screen>

      <para>Der Aufruf wird Lebenszyklus Phase site auslösen. Im Gegensatz zu
      den Standard-Build Lifecycle Phasen welche sich mit der Verwaltung von
      Codegeneration, der Manipulation von Ressourcen, Kompilierung,
      Packetierung und so weiter befassen betrifft diese Phase ausschließlich
      die Bearbeitung von Website-Content im Rahmen des <filename>/src/site</filename>
      Verzeichnisses und der Generierung von Reports. Nach Abschluss diesen
      Befehls, sollten Sie einen Projekt-Website im Verzeichnis <filename>/target/site</filename>
      vorfinden. Nach dem Laden der Datei <filename>/target/site/index.html</filename> sollten Sie
      das Skelett eines Projekt (Web-)Sites sehen. Diese Shell enthält bereits
      einige Berichte unter der Rubrik "Projekt Reports" der linken Navigation
      im Menü, sowie Informationen über das Projekt, dessen Abhängigkeiten und
      der Entwickler im Zusammenhang mit dem Projekt in der Rubrik
      "Projekt-Information". Die Projekt-Website dieses Beispiels ist
      größtenteils leer, da das POM nur sehr wenige Informationen über die
      reinen Koordinatenpunkte hinaus enthält: den Namen und die URL des
      Projektsites sowie der einzigen Test Abhängigkeit. </para>

      <para>Sie werden feststellen, dass auf dieser Website bereits einige
      Standard-Berichte bereitstehen, so gibt es einen Bericht, welcher den
      Ausgang der Unit-Tests zusammenfasst. Dieser Report spiegelt alle im
      Projekt erfolgten Unit Tests wieder, sowie im einzelnen deren Erfolg
      oder Misserfolg. Ein weiterer Report erzeugt die JavaDoc des Projekt
      API's. Maven bietet eine vollständige Palette von konfigurierbaren
      Reports, wie zum Beispiel dem Clover Report, welcher Aufschluss über die
      erfolgte Testabdeckung gibt, der JXR Report, ein Report welcher
      querverweisende HTML-Seiten generiert und speziell für Code-Reviews
      nützlich ist, der PMD Report, welcher, aufbauend auf eine
      Quellcodeanalyse, Aufschluss über eine Reihe von problematischen
      Kodierungen gibt, sowie der JDepend Report, welcher die Abhängigkeiten
      zwischen verschiedenen Packages einer Quellcodebasis analysiert. Die
      Reports der Website werden in der pom.xml Datei eines Builds
      konfiguriert.</para>
    </section>
  </section>

  <section id="simple-project-sect-summary">
    <title>Zusammenfassung </title>

    <para>Wir haben ein einfaches Projekt erstellt, in ein JAR-Archive
    gepackaged und diese JAR-Archive im lokalen Repository installiert um es
    anderen Projekten zur Verfügung zu stellen; sodann haben wir eine
    Projektwebsite der zugehörigen Dokumentation generiert. Wir konnten das
    alles bewerkstelligen, ohne auch nur einen einzige Zeile Code zu
    schreiben. Darüberhinaus haben wir Zeit aufgewandt einige der Kernkonzepte
    von Maven zu erläutern. Im nächsten Kapitel werden wir damit beginnen, die
    pom.xml-Datei anzupassen, weitere Abhängigkeiten einzufügen sowie einige
    Unit Tests zu konfigurieren.</para>
  </section>
</chapter>